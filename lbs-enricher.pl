#!/usr/bin/perl -w

# Copyright 2020-2022 Atle Solbakken atle@goliathdns.no / Posten Norge AS

# Any use, copying, modification or distribution of this code by others than
# representatives for Posten Norge AS or its vendors in service of Posten Norge AS
# is not permitted. Other use, copying, modification or distribution is permitted.

# By modifying this file you agree to the following terms:
# - You will not claim copyright or ownership to any modifications or additions 
# - All rights and ownership to any modifications or additions are credited to the
#   original copyright holders
# - Any modifications must immediately be presented back to the original copyright holders
# - This full original license header must remain unchanged

package main;

use rrr::rrr_helper;
use rrr::rrr_helper::rrr_message;
use rrr::rrr_helper::rrr_settings;
use rrr::rrr_helper::rrr_debug;

use strict;
use Sys::Hostname;
use Socket qw( :DEFAULT inet_ntop );
use bytes;
use Time::HiRes qw( gettimeofday tv_interval );
use Time::Local qw ( timelocal );
use POSIX;
use Data::Dumper;

# Debug activated rules and values which gets added or overwritten
my $API_DEBUG = 0;

# Debug response matching (R: parameter of rules) and API response values
my $API_DEBUG_RESPONSE = 0;
			
# Debug endpoints of asynchronous requests
my $API_DEBUG_ASYNC = 0;

# Debug missing rules if messages do not complete before timeout
my $API_DEBUG_NOT_APPLIED_RULES = 0;

# Print a message when a message is complete including processing time
my $API_DEBUG_COMPLETION = 0;

# Debug weight, tare and carrier type readings
my $DEBUG_READINGS = 0;

# Debug missing values for misc. rules before message times out
my $DEBUG_MISSING_VALUES = 1;

# Topics to ignore in case returned from the cacher (save commands, prefix)
my @API_RESPONSE_TOPICS_IGNORE = qw!lbs/api/carrier lbs/api/event lbs/api/quotient/!;

my $debug = { };
bless $debug, "rrr::rrr_helper::rrr_debug";

my $global_settings = undef;

# For scales sending readings continiously, all readings within this period must
# be stable (equal within a reasonable delta) for a reading to be accepted.
my $STABLE_WEIGHT_CHECK_PERIOD = 1.0;

# For scales sending a single guaranteed stable reading, allow some time for this
# to arrive in case any scanner input belonging to the same transaction arrives first.
my $STABLE_WEIGHT_LOOKUP_TIMEOUT = 2.0;

# Key is IP:PORT
my %global_push_service_cache;
my %global_weight_cache;
my %global_weight_stable_cache;
my %global_weight_history_cache;
my %global_tare_weight_cache;
my %global_carrier_type_cache;
my %global_carrier_content_cache;
my %global_carrier_content_count_cache;
my %global_quotient_count_cache;
my %global_twostep_cache;

# Key is MP_ID:SERIAL
my %global_carrier_save_cache;

# Messages to be enriched. A maximum number of messages may reside in the
# enrichment cache simultaneously. When the cache is full, new messages will
# not be moved from the input buffer.
my $ENRICHMENT_CACHE_MAX = 50;

# Only the first n messages in the queue may send async requests. The other
# messages will in many cases become enriched some responses generated by these
# first messages.
my $ENRICHMENT_ASYNC_ALLOWED_LIMIT = 30;

# Milliseconds to pause processing when no changes were perfomed in a message
# during iteration.
my $ENRICHMENT_NOTHING_HAPPENED_PAUSE_MS = 50;

my @global_enrichment_input_queue;
my %global_enrichment_cache;
my $global_enrichment_serial = 1;

#
# API methods
#
# # Comment
#
# M: Normal API method, local or remote. When all inputs in I: are avilable, and one
#    or more outputs O: are missing, method will be applied once
#
# A: Try again method, local only. Method is retried later if it does not immediately
#    produce a result
#
# I: Required input parameter(s) to method. Arguments are joined together with comma to remote API,
#    the local API receives a hash reference
#
# F:F Full message parameter list passed to local API.
#
# E: Specifies an optional endpoint to use for the rule. If not specified, the rule name will be used as endpoint.
#    Input Parameters may be enclosed in curly brackets, and these will be replaced with actual values.
#
# O: Expected output parameters in method response. All must be present in result from remote API,
#    returned parameters from local API is not validated
#
# P: Other parameters to save from API, identified by prefix
#
# R: Response match keys, remote API only. If all specified keys are present in a respons, all
#    messages which have the excact same values present will be updated with the O: fields.
#
# G: Group name. If defined, the rule will only be considered after the specified group has been
#    activated. May be set multiple times.
#

# Note : Internal API functions may return fewer, more or other parameters than those
#        specified in the output O: lines

my $global_api_methods = "
# 2.4.1.1
M:lbs/set-unix-timestamp
O:datestring_unix

# 2.4.1.2
M:lbs/set-lbs-timestamp
I:datestring_unix
O:datestring_lbs

# 2.4.1.3
M:lbs/set-internal-timestamp
O:datestring_gettimeofday

# 2.4.1.4
M:lbs/set-command-source
O:command_source

# 2.4.1.5
M:lbs/set-weekday
I:datestring_unix
O:weekday

# 2.4.2
A:lbs/print-timeout-message
F:F
I:gettimeofday_process
O:print_timeout_message_performed

# 2.4.3
A:lbs/debug-missing-values
F:F
I:gettimeofday_process
O:debug_missing_values_done

# 2.4.4
M:lbs/push-service
F:F
I:datestring_unix
O:push_service_performed

# 2.4.5
M:lbs/check-reading
F:F
I:datestring_unix
O:reading_performed

# 2.4.6
A:lbs/check-print-wait-ignore
F:F
I:datestring_gettimeofday
O:print_wait_ignore

# 2.4.7
A:lbs/send-push-notification
F:F
I:saved
O:push_notification_sent

# 2.4.8.1
M:lbs/cancel-id-ensure
O:cancel_id

# 2.4.8.2
M:lbs/cancel-check
F:F
I:cancel_id
O:cancel_performed

# 2.4.8.3
M:lbs/group-lbs-check
I:push_service_performed
I:reading_performed
I:cancel_performed
O:group_lbs_checked

# 2.4.9
M:lbs/twostep-start
G:twostep
F:F
I:twostep_start
I:scanner_ip
I:scanner_port
O:twostep_started

# 2.4.10
A:lbs/group-lbs-selection
G:lbs
F:F
O:group_selected

# 2.4.11.1
M:lbs/expand-irv
G:lbs
I:stacker
I:transportmethod
I:processdegree
I:velocity
I:label
O:code_prefix
O:twostep_start

# 2.4.11.2
M:lbs/expand-palletmani
G:lbs
I:machine
I:cellid
I:processdegree
I:product
I:transportmethod
I:format
I:velocity
I:label
I:weight
I:unladenweight
I:elements
I:carriertype
O:code_prefix
O:twostep_start

# 2.4.11.3
M:lbs/expand-telegram
G:lbs
I:machine
I:PRODUCTGROUP
I:PRODUCT
I:SERVICELEVEL
I:OUTPUT
I:LABELID
I:TRANSPORTMETHOD
I:PROCESSLEVEL
I:FORMAT
I:CARRIERTYPE
O:code_prefix
O:twostep_start

# 2.4.12
M:lbs/expand-barcode
G:lbs
F:F
I:barcode
O:code_prefix
O:twostep_start

# 2.4.13.1
M:lbs/api/get-tableau
G:tableau
I:tableau_id
O:source_meetingpoint_user_id_suggestion
O:transportation_type
O:carrier_type_suggestion
O:product_params
O:marking_ids
R:tableau_id

# 2.4.13.2
M:lbs/explode-tableau
G:tableau
F:F
I:scanner_ip
I:scanner_port
I:command_source
I:twostep_start
I:source_meetingpoint_user_id_suggestion
I:transportation_type
I:carrier_type_suggestion
I:product_params
I:code_prefix
I:marking_ids
I:tableau_id
I:event_measuringpoint_user_id
O:saved

# 2.4.15.1
M:lbs/expand-touch-tidreg
G:lbs
I:tidreg_mpid
O:code_prefix
O:twostep_start

# 2.4.15.2
M:lbs/expand-touch-twostep-command
G:lbs
I:twostep_command
O:code_prefix
O:twostep_start

# 2.4.15.3
M:lbs/expand-touch-carrier
G:lbs
I:marking_id
I:tableau_id
O:twostep_start
O:code_prefix

# 2.4.15.4
M:lbs/expand-touch-tableau
G:lbs
I:tableau_id
I:print_all
O:twostep_start
O:code_prefix

# 2.4.16
M:lbs/group-serial-check
G:lbs
I:code_prefix
I:twostep_start
O:group_serial_checked

# 2.4.17
A:lbs/send-scanner-ack
G:lbs
F:F
I:saved
O:scanner_ack_sent

# 2.4.18
M:lbs/machine-scanner-ensure
G:lbs
F:F
O:machine
O:scanner_ip
O:scanner_port

# 2.4.19.1
M:lbs/machine-scanner-check
G:lbs
I:machine
I:scanner_ip
I:scanner_port
O:machine_scanner_checked

# 2.4.19.2
M:lbs/api/get-printmachine
G:lbs-printmachine
I:client_name
I:machine
O:event_meetingpoint_user_id
O:event_measuringpoint_id
O:event_measuringpoint_postcode_id
O:event_measuringpoint_user_id
O:event_measuringpoint_type_name
O:terminal_name
O:postcode
O:postname
O:equipmenttype_name
O:client_description
O:client_type
O:timereg_meetingpoint_user_id_default
R:client_name
R:machine

# 2.4.19.3
M:lbs/api/get-identscanner
G:lbs-identscanner
I:client_name
I:scanner_ip
I:scanner_port
O:event_meetingpoint_user_id
O:event_measuringpoint_id
O:event_measuringpoint_postcode_id
O:event_measuringpoint_user_id
O:event_measuringpoint_type_name
O:terminal_name
O:postcode
O:postname
O:scanner_ip
O:scanner_port
O:equipmenttype_name
O:client_description
O:client_type
O:timereg_meetingpoint_user_id_default
R:client_name
R:scanner_ip
R:scanner_port

# 2.4.21
M:lbs/set-print-wait-ignore
G:twostep
G:timereg
G:tableau
I:message_id
O:print_wait_ignore

# 2.4.22
M:lbs/carrier-twostep-lookup
G:carrier-twostep-lookup
F:F
I:code_prefix
I:scanner_ip
I:scanner_port
O:carrier_twostep_command
O:carrier_twostep_command_reprocess

# 2.4.23
M:lbs/get-print-decition
G:carrier
I:code_prefix
I:carrier_twostep_command
O:print_decition

# 2.4.24
M:lbs/api/get-serial-carrier
G:serial-carrier
I:event_measuringpoint_user_id
O:event_measuringpoint_user_id
O:latest_serial
R:event_measuringpoint_user_id

# 2.4.25
M:lbs/increment-serial-carrier
G:serial-carrier
I:message_id
I:latest_serial
I:event_measuringpoint_user_id
O:serial
R:message_id

# 2.4.26
M:lbs/api/get-serial-timereg
G:serial-timereg
I:event_measuringpoint_user_id
O:event_measuringpoint_user_id
O:latest_serial
R:event_measuringpoint_user_id

# 2.4.27
M:lbs/increment-serial-timereg
G:serial-timereg
I:message_id
I:latest_serial
I:event_measuringpoint_user_id
O:serial
R:message_id

# 2.4.28
M:lbs/get-self-carrier-measuringpoint
G:carrier
I:code_prefix
I:event_measuringpoint_id
I:event_measuringpoint_postcode_id
I:event_measuringpoint_user_id
O:carrier_measuringpoint_postcode_id
O:carrier_measuringpoint_id
O:carrier_measuringpoint_user_id

# 2.4.29
M:lbs/get-self-source-meetingpoint-suggestion
G:carrier
I:code_prefix
I:event_meetingpoint_user_id
O:source_meetingpoint_user_id_suggestion
O:source_meetingpoint_suggestion_checked

# 2.4.30
M:lbs/group-marking-check
G:carrier
F:F
I:source_meetingpoint_suggestion_checked
I:transportation_type
O:group_marking_checked

# 2.4.31.1
M:lbs/get-print-barcode
G:carrier
I:code_prefix
I:carrier_type
I:carrier_measuringpoint_postcode_id
I:carrier_measuringpoint_id
I:product_params
I:marking_postcode_id
I:marking_id
I:weight
I:serial
I:marking_property_short
O:print_barcode

# 2.4.31.2
M:lbs/expand-print-barcode
G:carrier
I:print_barcode
O:code_prefix
O:carrier_measuringpoint_postcode_id
O:carrier_measuringpoint_id
O:carrier_measuringpoint_user_id

# 2.4.32.1
M:lbs/set-client-requirements
G:carrier
I:client_type
O:carrier_type_enforce
O:tare_weight_enforce

# 2.4.32.2
M:lbs/set-zero-chute-name
G:carrier
O:chute_name

# 2.4.32.3
M:lbs/set-tray-count
G:carrier
F:F
I:scale_ip
I:scale_port
I:carrier_type
O:tray_count

# 2.4.32.4
M:lbs/set-sequence
G:carrier
O:sequence

# 2.4.33.1
M:lbs/quotient-uptake
G:quotient-uptake
I:event_measuringpoint_user_id
I:scale_ip
I:scale_port
I:weight_grams
I:tare_weight
I:weight_check_complete
O:quotient_uptake_measurement
O:quotient_uptake_count
O:quotient_uptake_weight
O:quotient_decition

# 2.4.33.2
M:lbs/debug-quotient-uptake
G:quotient-uptake
F:F
I:event_measuringpoint_user_id
I:barcode
I:product_params_format
I:product_params_service_level
I:product_params_group
I:marking_property_short
I:quotient_decition
O:debug_quotient_done

# 2.4.33.3
M:lbs/api/quotient-uptake-save
G:carrier-save-quotient-uptake
E:lbs/api/quotient/{carrier_measuringpoint_postcode_id}/{carrier_measuringpoint_id}/{serial}
I:message_id
I:carrier_measuringpoint_postcode_id
I:carrier_measuringpoint_id
I:event_measuringpoint_user_id
I:event_measuringpoint_postcode_id
I:event_measuringpoint_id
I:serial
I:product_params_format
I:product_params_service_level
I:product_params_group
I:marking_property_short
I:delivery_postcode_id
I:quotient_uptake_measurement
I:quotient_uptake_count
I:quotient_uptake_weight
I:datestring_unix
O:quotient_uptake_saved
R:message_id

# 2.4.35.1
M:lbs/lookup-tare-weight
G:carrier
F:F
I:scale_ip
I:scale_port
O:tare_weight
O:tare_weight_is_from_message

# 2.4.35.2
M:lbs/set-weightless-command
G:carrier
I:carrier_twostep_command
O:weightless_command

# 2.4.35.3
M:lbs/set-tare-weight
G:carrier
F:F
I:weightless_command
I:tare_weight_enforce
I:carrier_weight
I:event_measuringpoint_user_id
I:tare_weight_is_from_message
O:tare_weight
O:tare_weight_checked

# 2.4.35.4.1
A:lbs/lookup-stable-weight
G:carrier
I:scale_ip
I:scale_port
I:gettimeofday_process
I:event_measuringpoint_type_name
I:event_measuringpoint_user_id
I:weight_stable_cleared
O:weight_stable

# 2.4.35.4.2
M:lbs/clear-stable-weight
G:carrier
I:scale_ip
I:scale_port
I:event_measuringpoint_type_name
I:event_measuringpoint_user_id
O:weight_stable_cleared

# 2.4.35.5
A:lbs/set-weight
G:carrier
F:F
I:weightless_command
I:weight_stable
I:tare_weight_checked
I:event_measuringpoint_user_id
I:scale_ip
I:scale_port
I:tare_weight
I:sequence
O:weight
O:weight_check_complete

# 2.4.35.6
M:lbs/set-weight-grams
G:carrier
I:scale_ip
I:scale_port
I:weight
I:weight_stable
I:weight_check_complete
O:weight_grams

# 2.4.36
M:lbs/merge-product-params-carrier
G:carrier
I:product_params_group
I:product_params_service_level
I:product_params_product
I:product_params_format
I:product_params_process_degree
O:product_params

# 2.4.37
M:lbs/expand-product-params-carrier
G:carrier
I:product_params
I:message_id
O:product_params_group
O:product_params_service_level
O:product_params_product
O:product_params_format
O:product_params_process_degree

# 2.4.38.1
M:lbs/group-aths-check
G:carrier
I:code_prefix
O:group_aths_checked

# 2.4.38.2
M:aths/lb-lookup
G:lb_lookup
I:lb_lookup_barcode
I:event_measuringpoint_user_id
O:lb_lookup_barcode
O:print_barcode
O:saved
R:lb_lookup_barcode

# 2.4.39.1
M:lbs/lookup-carrier-type
G:carrier
F:F
I:scale_ip
I:scale_port
O:carrier_type
O:carrier_type_is_from_message

# 2.4.39.2
M:lbs/set-carrier-type
G:carrier
F:F
I:carrier_type_suggestion
I:carrier_type_enforce
I:event_measuringpoint_user_id
I:carrier_type_is_from_message
O:carrier_type_suggestion
O:carrier_type

# 2.4.40.1
M:lbs/group-carrier-quotient-check
G:carrier
I:carrier_twostep_command
I:event_measuringpoint_type_name
O:group_carrier_quotient_checked

# 2.4.40.2
M:lbs/api/get-quotient-parameters
G:carrier-quotient-divert
I:carrier_measuringpoint_postcode_id
I:product_params_service_level
I:product_params_format
I:marking_property_short
O:quotient_params_letters
O:quotient_params_interval
O:quotient_params_weight_min
R:carrier_measuringpoint_postcode_id
R:product_params_service_level
R:product_params_format
R:marking_property_short

# 2.4.40.3
M:lbs/group-carrier-quotient-count-check
G:carrier-quotient-divert
I:event_measuringpoint_user_id
I:quotient_params_interval
O:group_carrier_quotient_count_checked

# 2.4.40.4
M:lbs/get-quotient-counter
G:carrier-quotient-count
I:message_id
I:carrier_measuringpoint_postcode_id
I:product_params_group
I:product_params_service_level
I:product_params_product
I:product_params_format
I:product_params_process_degree
I:marking_property_short
O:quotient_counter
R:message_id

# 2.4.40.5
M:lbs/get-quotient-decition
G:carrier-quotient-count
I:quotient_counter
I:quotient_params_interval
O:quotient_decition

# 2.4.40.6
M:lbs/set-quotient-diverter-decition
G:carrier-quotient-diverter-command
I:quotient_decition
O:diverter_decition

# 2.4.40.7
M:lbs/debug-quotient-count
G:carrier-quotient-count
I:event_measuringpoint_user_id
I:carrier_measuringpoint_postcode_id
I:product_params
I:product_params_group
I:product_params_service_level
I:product_params_product
I:product_params_format
I:product_params_process_degree
I:marking_property_short
I:quotient_params_interval
I:quotient_counter
I:quotient_decition
O:debug_quotient_done

#### 2.4.40.8
M:lbs/carrier-quotient-divert-check
G:carrier-quotient-divert-check
I:carrier_measuringpoint_user_id
I:serial
I:event_measuringpoint_user_id
O:carrier_quotient_divert_possible

# 2.4.41
M:lbs/send-diverter-command
G:diverter
I:event_measuringpoint_user_id
I:diverter_decition
I:diverter_command_straight
I:diverter_command_diverge
I:diverter_ip
I:diverter_port
O:diverter_command_sent

# 2.4.42.1
M:lbs/group-carrier-print-check
I:weight_check_complete
G:carrier
O:group_carrier_print_checked

# 2.4.42.2
A:lbs/print-wait
G:carrier-print
F:F
I:saved
I:message_id
O:print_wait_complete

# 2.4.43.1
M:lbs/print-copies-ensure
G:carrier-print
O:print_copies

# 2.4.43.2
M:lbs/printer-ip-force-ensure
G:carrier-print
O:printer_ip_force

# 2.4.43.3
M:lbs/print-disable-ensure
G:carrier-print
O:print_disable

# 2.4.43.4
M:lbs/print-failover-ensure
G:carrier-print
O:print_failover

# 2.4.43.5
M:lbs/debug-print
G:carrier-print
F:F
I:print_decition
I:print_wait_complete
I:command_source
I:print_barcode
I:print_copies
I:event_measuringpoint_user_id
I:sequence
O:debug_print_done

# 2.4.43.6
M:lbs/print
G:carrier-print
F:F
I:printer_ip_force
I:print_disable
I:print_failover
I:print_decition
I:print_wait_complete
I:printer_sorted_count
I:print_barcode
I:terminal_name
I:datestring_lbs
I:weekday
I:product_params_format_text
I:product_params_process_degree_text
I:event_measuringpoint_id
I:marking_text
I:marking_text_extra
I:marking_text_help_1
I:marking_text_help_2
I:marking_text_help_3
I:weight
I:marking_postcode_id
I:postcode
I:client_description
I:marking_frequency
I:chute_name
I:carrier_type
I:event_measuringpoint_user_id
I:tray_count
O:printed

# 2.4.44.1
M:lbs/check-tableau-id-precence
G:carrier
F:F
O:tableau_id_precence_checked

# 2.4.44.2
M:lbs/set-zero-label-group-id
G:carrier-tableau-unknown
O:label_group_id

# 2.4.44.3
M:lbs/api/get-tableau-with-marking
G:carrier-tableau-known
I:marking_id
I:tableau_id
O:source_meetingpoint_user_id_suggestion
O:transportation_type
O:carrier_type_suggestion
O:product_params
O:label_group_id
R:tableau_id
R:marking_id

# 2.4.45.1. lbs/api/get-product-params-format-text
M:lbs/api/get-product-params-format-text
G:carrier
I:product_params_group
I:product_params_format
O:product_params_format_text
R:product_params_group
R:product_params_format

# 2.4.45.2. lbs/api/get-product-params-process-degree-text
M:lbs/api/get-product-params-process-degree-text
G:carrier
I:product_params_group
I:product_params_process_degree
O:product_params_process_degree_text
R:product_params_group
R:product_params_process_degree

# 2.4.45.3. lbs/api/get-quotient
M:lbs/api/get-quotient
G:carrier
I:carrier_measuringpoint_postcode_id
I:product_params_group
I:product_params_service_level
I:product_params_format
O:quotient
R:carrier_measuringpoint_postcode_id
R:product_params_group
R:product_params_service_level
R:product_params_format

# 2.4.45.4. lbs/api/get-carrier
M:lbs/api/get-carrier
G:carrier
I:carrier_type
O:carrier_weight
R:carrier_type

# 2.4.46
M:lbs/group-carrier-save-check
I:quotient_decition
I:weight_check_complete
G:carrier
O:group_carrier_save_checked

# 2.4.47.1
M:lbs/expand-event
G:carrier-save
I:code_prefix
I:carrier_twostep_command
I:quotient_decition
I:event_measuringpoint_user_id
I:event_measuringpoint_type_name
I:source_meetingpoint_user_id
I:marking_property_long
I:weight
I:tare_weight
I:carrier_type
I:tray_count
I:print_barcode
I:sequence
O:event_code_primary
O:event_code_secondary
O:event_migration
O:expand_event_complete

# 2.4.47.2
M:lbs/api/carrier-save-event-primary
E:lbs/api/event/{carrier_measuringpoint_user_id}/{serial}/{event_measuringpoint_user_id}/{event_code_primary}/{datestring_unix}
G:carrier-save-event-primary
I:message_id
I:event_meetingpoint_user_id
I:event_measuringpoint_user_id
I:event_measuringpoint_postcode_id
I:event_measuringpoint_id
I:carrier_measuringpoint_user_id
I:carrier_measuringpoint_postcode_id
I:carrier_measuringpoint_id
I:serial 
I:datestring_unix
I:event_code_primary
I:event_migration
O:event_primary_saved
R:message_id

# 2.4.47.3
M:lbs/api/carrier-save-event-secondary
E:lbs/api/event/{carrier_measuringpoint_user_id}/{serial}/{event_measuringpoint_user_id}/{event_code_secondary}/{datestring_unix}
G:carrier-save-event-secondary
I:message_id
I:event_meetingpoint_user_id
I:event_measuringpoint_user_id
I:event_measuringpoint_postcode_id
I:event_measuringpoint_id
I:carrier_measuringpoint_user_id
I:carrier_measuringpoint_postcode_id
I:carrier_measuringpoint_id
I:serial 
I:datestring_unix
I:event_code_secondary
O:event_secondary_saved
R:message_id

# 2.4.47.4.
M:lbs/carrier-save-carrier-cache
G:carrier-save-carrier
I:carrier_measuringpoint_user_id
I:serial
O:carrier_cache_saved

# 2.4.47.5
M:lbs/api/carrier-save-carrier
E:lbs/api/carrier/{carrier_measuringpoint_user_id}/{serial}
G:carrier-save-carrier
I:message_id
I:carrier_measuringpoint_postcode_id
I:carrier_measuringpoint_id
I:carrier_measuringpoint_user_id
I:serial
I:code_prefix
I:product_params_group
I:product_params_process_degree
I:product_params_service_level
I:product_params_product
I:product_params_format
I:carrier_type
I:weight
I:tare_weight
I:transport_method
I:event_meetingpoint_user_id
I:source_meetingpoint_user_id_suggestion
I:source_meetingpoint_user_id
I:destination_meetingpoint_user_id
I:tray_count
I:quotient
I:marking_postcode_id
I:marking_id
I:event_measuringpoint_user_id
I:event_measuringpoint_postcode_id
I:event_measuringpoint_id
I:delivery_postcode_id
I:datestring_unix
O:carrier_saved
R:message_id

# 2.4.47.6. lbs/carrier-save-confirm-all
M:lbs/carrier-save-confirm-all
G:carrier-save-confirm-all
I:event_primary_saved
I:event_secondary_saved
I:carrier_saved
O:saved

# 2.4.47.7. lbs/carrier-save-confirm-primary
M:lbs/carrier-save-confirm-primary
G:carrier-save-confirm-primary
I:event_primary_saved
O:saved

# 2.4.47.8. lbs/carrier-save-confirm-primary-secondary
M:lbs/carrier-save-confirm-primary-secondary
G:carrier-save-confirm-primary-secondary
I:event_primary_saved
I:event_secondary_saved
O:saved

# 2.4.47.9. lbs/carrier-save-ignore
M:lbs/carrier-save-ignore
G:carrier-save-ignore
O:saved

# 2.4.48.1
M:lbs/api/get-xmarking
G:carrier-xmrk
I:marking_id
I:source_meetingpoint_user_id_min
I:source_meetingpoint_user_id_max
I:transportation_type
O:marking_postcode_id
O:source_meetingpoint_user_id_xmarking
O:destination_meetingpoint_user_id
O:marking_property_long
O:marking_frequency
O:marking_text
O:marking_text_extra
O:delivery_postcode_id
O:marking_text_help_1
O:marking_text_help_2
O:marking_text_help_3
R:marking_id
R:source_meetingpoint_user_id_min
R:source_meetingpoint_user_id_max
R:transportation_type

# 2.4.48.2.
M:lbs/trim-marking-property
G:carrier-xmrk
I:marking_property_long
O:marking_property_short

# 2.4.48.3.
M:lbs/deduct-transport-method
G:carrier-xmrk
I:transportation_type
O:transport_method
	
# 2.4.48.4.
M:lbs/set-source-meetingpoint-min-max
G:carrier-xmrk
I:transportation_type
I:source_meetingpoint_user_id_suggestion
O:source_meetingpoint_user_id_min
O:source_meetingpoint_user_id_max

# 2.4.48.5.
M:lbs/debug-xmarking
G:carrier-xmrk
F:F
I:marking_id
I:transportation_type
I:source_meetingpoint_user_id_min
I:source_meetingpoint_user_id_max
I:event_measuringpoint_user_id
O:debug_xmarking_done

# 2.4.48.6.
M:lbs/deduct-xmarking-source-meetingpoint
G:carrier-xmrk
I:transportation_type
I:source_meetingpoint_user_id_xmarking
I:source_meetingpoint_user_id_suggestion
O:source_meetingpoint_user_id

# 2.4.49.1.
M:lbs/api/get-marking
G:carrier-marking
I:marking_id
O:marking_frequency
O:marking_text
O:marking_text_extra
O:marking_property_long
O:delivery_postcode_id
O:destination_meetingpoint_user_id
O:marking_text_help_1
O:marking_text_help_2
O:marking_text_help_3
R:marking_id

# 2.4.49.2.
M:lbs/debug-marking
G:carrier-marking
F:F
I:marking_id
I:event_measuringpoint_user_id
O:debug_marking_done

# 2.4.50.1
M:lbs/api/get-measuringpoint-printer
G:carrier
I:event_measuringpoint_postcode_id
I:event_measuringpoint_id
I:carrier_type
I:label_group_id
O:printer_count
P:printer_
R:event_measuringpoint_postcode_id
R:event_measuringpoint_id
R:carrier_type

# 2.4.50.2
M:lbs/api/get-measuringpoint-scale
G:carrier
I:event_measuringpoint_postcode_id
I:event_measuringpoint_id
O:scale_ip
O:scale_port
R:event_measuringpoint_postcode_id
R:event_measuringpoint_id

# 2.4.50.3.
M:lbs/api/get-measuringpoint-diverter
G:carrier
I:event_measuringpoint_postcode_id
I:event_measuringpoint_id
O:diverter_ip
O:diverter_port
O:diverter_command_straight
O:diverter_command_diverge
R:event_measuringpoint_postcode_id
R:event_measuringpoint_id

# 2.4.51
M:lbs/timereg-twostep-lookup
G:timereg
I:scanner_port
I:scanner_ip
I:timereg_subject
I:timereg_meetingpoint_user_id_default
O:timereg_prefix
O:timereg_meetingpoint_user_id
O:timereg_suffix

# 2.4.52.1
M:lbs/expand-product-params-tidreg
G:timereg
I:timereg_suffix
O:product_params_group
O:product_params_product
O:product_params_service_level
O:product_params_format

# 2.4.52.2
M:lbs/check-timereg-expiration
G:timereg
I:timereg_code_day
I:timereg_code_month
I:timereg_code_year
I:timereg_code_valid
O:timereg_expired

# 2.4.52.3
M:lbs/group-timereg-save-check
G:timereg
I:timereg_expired
O:group_timereg_save_checked

# 2.4.53.1
M:lbs/debug-timereg
G:timereg
I:timereg_meetingpoint_user_id
I:timereg_subject_prefix
I:timereg_subject
I:timereg_expired
I:serial
I:event_measuringpoint_user_id
O:debug_timereg_done

# 2.4.53.2
M:lbs/api/save-timereg
E:lbs/api/timereg/{event_measuringpoint_user_id}/{serial}
G:timereg-save
I:message_id
I:event_measuringpoint_postcode_id
I:event_measuringpoint_id
I:serial
I:timereg_subject_prefix
I:timereg_prefix
I:timereg_subject
I:timereg_expired
I:event_meetingpoint_user_id
I:timereg_meetingpoint_user_id
I:product_params_group
I:product_params_product
I:product_params_service_level
I:product_params_format
I:event_measuringpoint_user_id
I:datestring_unix
O:saved
R:message_id

# 2.4.54
M:lbs/sort-printers
G:carrier
I:printer_count
I:print_decition
I:chute_name
F:F
O:printers_sorted

# 2.4.55
M:lbs/set-client-name
G:lbs
O:client_name

# 2.4.56
M:lbs/carrier-twostep-reprocess
G:carrier
I:carrier_twostep_command_reprocess
I:print_barcode
I:scanner_ip
I:scanner_port
I:weight_grams
I:weight
I:tare_weight
I:tray_count
I:saved
O:carrier_twostep_reprocess_complete

";

my %global_api_matrix;

my $i = 1;
my $cur_m = undef;
foreach my $line (split(/[\r\n]+/, $global_api_methods)) {
	$line =~ s/\s+//g;
	if ($line eq "" || $line =~ /^\s*#/) {
		next;
	}
	elsif ($line !~ /^([\w])\:(.+)$/) {
		die("Invalid syntax in API matrix line $i: '$line'\n");
	}

	my $cmd = $1;
	my $arg = $2;

	if ($cmd eq "M" || $cmd eq "A") {
		$cur_m = $arg;
		$global_api_matrix{$cur_m} = {
			'name' => $cur_m,
			'inputs' => [],
			'outputs' => [],
			'output_prefixes' => [],
			'response_matches' => [],
			'again' => ($cmd eq "A" ? 1 : 0),
			'full_message' => 0,
			'method_groups' => {}
			# endpoint is left undefined initially
		};
	}
	elsif (!defined $cur_m) {
		die("Invalid syntax in API matrix line $i: argument '$line' defined without method name M first\n");
	}
	elsif ($cmd eq "I") {
		push @{$global_api_matrix{$cur_m}->{'inputs'}}, $arg;
	}
	elsif ($cmd eq "O") {
		push @{$global_api_matrix{$cur_m}->{'outputs'}}, $arg;
	}
	elsif ($cmd eq "P") {
		push @{$global_api_matrix{$cur_m}->{'output_prefixes'}}, $arg;
	}
	elsif ($cmd eq "R") {
		push @{$global_api_matrix{$cur_m}->{'response_matches'}}, $arg;
	}
	elsif ($cmd eq "F" and $arg eq "F") {
		$global_api_matrix{$cur_m}->{'full_message'} = 1;
	}
	elsif ($cmd eq "G") {
		if (defined $global_api_matrix{$cur_m}->{'method_groups'}->{$arg}) {
			die("Group $arg specified twice for an API rule line $i\n");
		}
		$global_api_matrix{$cur_m}->{'method_groups'}->{$arg} = 1;
	}
	elsif ($cmd eq "E") {
		if (defined $global_api_matrix{$cur_m}->{'method_endpoint'}) {
			die("E: specified twice for an API rule line $i\n");
		}
		$global_api_matrix{$cur_m}->{'endpoint'} = $arg;
	}
	else {
		die("Invalid syntax in API matrix line $i: argument '$line' has unknown command $cmd\n");
	}

	$i++;
}

sub make_ident_msg {
	my $msg = shift;
	my $ident = shift;
	$msg = "<IDENT:" . zerofill ($ident, 7) . "> $msg";
}

sub print_error_ident {
	my $msg = shift;
	my $measuringpoint_user_id = shift;
	$msg = make_ident_msg($msg, $measuringpoint_user_id);
	print_error($msg);
}

sub print_info_ident {
	my $msg = shift;
	my $measuringpoint_user_id = shift;
	$msg = make_ident_msg($msg, $measuringpoint_user_id);
	print_info($msg);
}

sub print_error {
	my $msg = shift;
	$debug->msg(0, $msg);
}

sub print_info {
	my $msg = shift;
	$debug->msg(1, $msg);
}

sub print_debug {
	my $msg = shift;
	$debug->msg(3, $msg);
}

sub is_set {
	my $hash = shift;
	my $key = shift;
	return exists $hash->{$key};
}

sub is_zero {
	my $hash = shift;
	my $key = shift;
	return defined $hash->{$key} && $hash->{$key} eq "0";
}

sub is_nonzero {
	my $hash = shift;
	my $key = shift;
	return defined $hash->{$key} && $hash->{$key};
}

sub is_nonempty {
	my $hash = shift;
	my $key = shift;
	return defined $hash->{$key} && $hash->{$key} ne "";
}

sub is_yes {
	my $hash = shift;
	my $key = shift;
	return is_nonzero($hash, $key) && $hash->{$key} eq "yes";
}

sub is_no {
	my $hash = shift;
	my $key = shift;
	return is_nonzero($hash, $key) && $hash->{$key} eq "no";
}

sub is_numeric {
	my $hash = shift;
	my $key = shift;
	return $hash->{$key} =~ /^(\d+)(\.\d+|)$/;
}

sub is_equal_to {
	my $hash = shift;
	my $key = shift;
	my $value = shift;
	return is_nonzero($hash, $key) && $hash->{$key} eq $value;
}

sub set_ip {
	my $message = shift;
	my $ip_addr = shift;
	my $port = shift;
	my $ip_so_type = shift;

	my $result = $message->ip_set($ip_addr, $port);
	   $result += $message->ip_set_protocol($ip_so_type);

	if ($result != 2) {
		print_error("Warning: Error while setting IP/protocol in message\n");
	}

	return ($result == 2);
}

# Returns first value only
sub get_from_tag_first {
	my $message = shift;
	my $tag = shift;

	return ($message->get_tag_all($tag))[0];
}

# Returns first value only
sub get_from_tag_or_default {
	my $message = shift;
	my $tag = shift;
	my $default = shift;
	
	my $result = ($message->get_tag_all($tag))[0];
	
	if (!defined $result) {
		return $default;
	}
	
	return $result;
}

sub set_tag_blob {
	my $message = shift;
	my $tag = shift;
	my $value = shift;
	if (!defined $value or $value eq "") {
		print_info("Warning: Pushed empty value for tag $tag to array\n");
	}
	return $message->set_tag_blob($tag, $value, length $value);
}

sub set_tag_str {
	my $message = shift;
	my $tag = shift;
	my $value = shift;
	return $message->set_tag_str($tag, $value);
}

sub get_ip_and_port {
	my $message = shift;

	my ($ip, $port) = $message->ip_get();

	# RFC4291
	if (defined $ip) {
		my @result;

		$ip =~ s/^.*ffff[\.:](\d+\.\d+\.\d+\.\d+)$/$1/i;

		push @result, $ip;
		push @result, $port;

		return @result;
	}

	return undef;
}

sub hex_to_dec {
	my $hex = shift;
	my @chars = split //, $hex;
	
	my $result = 0;
	my $factor = 1;
	for (my $i = @chars - 1; $i >= 0; $i--) {
		$result += $factor * hex("0x" . $chars[$i]);
		$factor *= 16;
	}
	
	return $result;
}

sub zerofill {
	my $subject = shift;
	my $total_characters = shift;

	if (!defined $subject) {
		return undef;
	}

	my $result = $subject;

	while (length $result < $total_characters) {
		$result = "0" . $result;
	}

	return $result;
}

sub zerotrim {
	my $subject = shift;

	$subject =~ s/^0+(\d+)$/$1/;

	return $subject;
}

sub date_to_time {
	my $day = shift;
	my $month = shift;
	my $year = shift;

	return timelocal (0, 0, 0, $day, $month - 1, $year);
}

sub get_localtime_array {
	my $time = shift;

	if (!defined $time) {
		$time = time;
	}

	my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime($time);
	
	$year += 1900;
	$mon += 1;
	
	$sec = sprintf("%02d", $sec);
	$min = sprintf("%02d", $min);
	$hour = sprintf("%02d", $hour);
	$mday = sprintf("%02d", $mday);
	$mon = sprintf("%02d", $mon);
	
	my @tmp = ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst);

	return \@tmp;
}

sub get_lbs_datestring {
	my $localtime = shift;
	
	my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = @{$localtime};
	
	return "$mday.$mon.$year $hour:$min:$sec";
}

sub get_weekday {
	my $localtime = shift;
	
	my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = @{$localtime};

	my @weekdays = qw/SØNDAG MANDAG TIRSDAG ONSDAG TORSDAG FREDAG LØRDAG/;

	return $weekdays[$wday];
}

sub get_future_time {
	my $add_us = shift;

	my @time = gettimeofday;

	$time[1] += $add_us;

	$time[0] += ($time[1] - ($time[1] % 1000000)) / 1000000;
	$time[1] = $time[1] % 1000000;

	#	printf("Set grace " . tv_interval(\@time) . "\n");

	return \@time;
}

sub config {
	my $settings = shift;

	my %tmp;	

	my @keys = (
		"lbs_fake_hostname",
		"lbs_weight_timeout",
		"lbs_twostep_timeout",
		"lbs_reprint_request_timeout",
		"lbs_enrichment_timeout",
		"lbs_topic_aths_lb_lookup_request",
		"lbs_topic_aths_lb_lookup_response",
		"lbs_topic_push",
		"lbs_topic_beep",
		"lbs_topic_ip_response",
		"lbs_topic_print",
		"lbs_topic_incrementer_quotient_counter_prefix",
		"lbs_topic_incrementer_id_prefix",
		"lbs_tag_incrementer_id_serial",
		"lbs_print_copies",
		"lbs_printer_ip_force",
		"lbs_print_disable",
		"lbs_print_failover"
	);
	my @keys_yes_no = ();
	my @keys_integer = (
		"lbs_weight_timeout",
		"lbs_twostep_timeout",
		"lbs_reprint_request_timeout",
		"lbs_enrichment_timeout",
		"lbs_print_copies"
	);

	foreach my $key (@keys) {
		$tmp{$key} = $settings->get($key);
		if (!defined $tmp{$key}) {
			$tmp{$key} = "";
		}
	}

	foreach my $key (@keys_yes_no) {
		if ($tmp{$key} =~ /^(no?|0)$/i) {
			$tmp{$key} = 0;
		}
		elsif ($tmp{$key} =~ /^(y(es|)|1)$/i) {
			$tmp{$key} = 1;
		}
		else {
			print_error ("Warning: Could not understand yes/no configuration parameter $key, value was '$tmp{$key}'. Defaulting to 'no'.\n");
			$tmp{$key} = 0;
		}
	}

	foreach my $key (@keys_integer) {
		if ($tmp{$key} =~ /^\d+$/) {
			# OK
		}
		else {
			print_error ("Warning: Could not understand integer configuration parameter $key, value was '$tmp{$key}'. Defaulting to '0'.\n");
			$tmp{$key} = 0;
		}
	}

	$global_settings = \%tmp;

	print_info ("Starting RRR LBS Enricher using hostname " . $global_settings->{'lbs_fake_hostname'} . "\n");

	return 1;
}

sub cache_ensure_timeout_defined {
	my $name = shift;

	if (!(defined  $global_settings->{$name}) || $global_settings->{$name} < 1) {
		print_error("Warning: $name not specified in configuration. Using 10 seconds.");
		$global_settings->{$name} = 10;
	}
}

sub cache_housekeep {
	my $cache = shift;
	my $timeout_s = shift;

	my $expiration_time = time - $timeout_s;

	foreach my $key (keys (%{$cache})) {
		if ($cache->{$key}->{'timestamp'} < $expiration_time) {
			#print_info("A message expired during housekeeping\n");
			delete $cache->{$key};
		}
	}
}

sub cache_housekeep_all {
	cache_ensure_timeout_defined('lbs_weight_timeout');
	cache_ensure_timeout_defined('lbs_twostep_timeout');
	cache_ensure_timeout_defined('lbs_enrichment_timeout');

	cache_housekeep(\%global_push_service_cache, 2); # Two seconds
	cache_housekeep(\%global_tare_weight_cache, 1); # One second
	cache_housekeep(\%global_carrier_type_cache, 1); # One second
	cache_housekeep(\%global_carrier_content_cache, 1); # One second
	cache_housekeep(\%global_carrier_content_count_cache, 1); # One second
	cache_housekeep(\%global_quotient_count_cache, 5); # Five seconds
	cache_housekeep(\%global_weight_cache, $global_settings->{'lbs_weight_timeout'});
	cache_housekeep(\%global_weight_stable_cache, $global_settings->{'lbs_weight_timeout'});
	cache_housekeep(\%global_weight_history_cache, $global_settings->{'lbs_weight_timeout'});

	cache_housekeep(\%global_twostep_cache, $global_settings->{'lbs_twostep_timeout'});
	cache_housekeep(\%global_carrier_save_cache, 3600); # One hour
	cache_housekeep(\%global_enrichment_cache, $global_settings->{'lbs_enrichment_timeout'});
}

sub cache_lookup {
	my $cache = shift;
	my $key = shift;
	my $tag = shift;

	if (!defined $cache->{$key}) {
		return undef;
	}

	return $cache->{$key}->{$tag};
}

sub cache_lookup_and_clear {
	my $cache = shift;
	my $key = shift;
	my $tag = shift;

	my $ret = cache_lookup($cache, $key, $tag);

	cache_clear($cache, $key);

	return $ret;
}

sub cache_lookup_hashref {
	my $cache = shift;
	my $key = shift;

	return $cache->{$key};
}

sub cache_clear {
	my $cache = shift;
	my $key = shift;
	delete $cache->{$key};
}

sub cache_push {
	my $cache = shift;
	my $key = shift;
	my $tag = shift;
	my $value = shift;

	my $target = $cache->{$key};
	if (!defined $target) {
		$cache->{$key} = {};
		$target = $cache->{$key};
	}

	$target->{$tag} = $value;
	$target->{'timestamp'} = time;
}

sub cache_push_hashref {
	my $cache = shift;
	my $key = shift;
	my $ref = shift;

	$cache->{$key} = $ref;
	$cache->{$key}->{'timestamp'} = time;
}

sub send_barcode_push {
	my $message = shift;
	my $barcode = shift;

	set_tag_blob ($message, "barcode", $barcode);
	set_tag_blob ($message, "port", 0);

	$message->{'topic'} = $global_settings->{'lbs_topic_push'};
#	print "Topic is : " . $message->{'topic'} . "\n";
	$message->send();
}

sub send_log_message_push {
	my $message = shift;
	my $loglevel = shift;
	my $data = shift;

	set_tag_blob ($message, "loglevel", $loglevel);
	set_tag_blob ($message, "data", $data);
	set_tag_blob ($message, "port", 0);

	$message->{'topic'} = $global_settings->{'lbs_topic_push'};
#	print "Topic is : " . $message->{'topic'} . "\n";
	$message->send();
}

sub send_log_message_beep {
	my $message = shift;
	my $data = shift;

	set_tag_blob ($message, "data", $data);

	$message->{'topic'} = $global_settings->{'lbs_topic_beep'};
#	print "Topic is : " . $message->{'topic'} . "\n";
	$message->send();
}

sub send_message_ip {
	my $message = shift;
	my $data = shift;
	$message->{'topic'} = $global_settings->{'lbs_topic_ip_response'};
	set_tag_blob($message, "response", $data);
	$message->send();
}

sub process_barcode_1Y_5Y {
	my $barcode = shift;

	# 1Y6 00201181214080002282900000000213
	# 5Y6 00201181214080002282900000000213

	if ($barcode !~ /^([15]Y)(\d)(\d{4})(\d{3})(\d{5})(\d{4})(\d{5})(\d{3})(\d{7})(\d{1})$/) {
		return undef;
	}

	my $KODEPREFIKS = $1;
	my $LB = $2;
	my $MP_IDPO = $3;
	my $MP_IDSK = $4;
	my $PRODUCTPARAMS = $5;
	my $POSTNRANKOMST = $6;
	my $IDENTMERKING = $7;
	my $VEKTSTREKKODE = $8;
	my $LOPENR = $9;
	my $IDENTMEFO = $10;

	my %result = (
		"carrier_type" => $LB,
		"carrier_type_suggestion" => $LB,
		"carrier_measuringpoint_user_id" => $MP_IDPO . $MP_IDSK,
		"carrier_measuringpoint_postcode_id" => $MP_IDPO,
		"carrier_measuringpoint_id" => $MP_IDSK,
		"product_params" => $PRODUCTPARAMS,
		"marking_postcode_id" => $POSTNRANKOMST,
		"marking_id" => $IDENTMERKING,
		"serial" => $LOPENR,
		"marking_property_short" => $IDENTMEFO,
		# Passthrough, this will prevent save (but create passing). All values
		# otherwise returned exclusively from get-xmrk must be set
		"source_meetingpoint_user_id_suggestion" => 0,
		"source_meetingpoint_user_id" => 0,
		"destination_meetingpoint_user_id" => 0,
		"transport_method" => 0,
		"transportation_type" => "no-xmrk"
	);

	return \%result;
}

sub process_barcode_2Y {
	my $barcode = shift;

	# 2Y6 00201181214080002282900000000004

	if ($barcode !~ /^(2Y)(\d)(\d{4})(\d{3})(\d{5})(\d{4})(\d{5})(000)(0000000)(\d{1})$/) {
		return undef;
	}

	my $KODEPREFIKS = $1;
	my $LB = $2;
	my $MP_IDPO = $3;
	my $MP_IDMP = $4;
	my $PRODUCTPARAMS = $5;
	my $POSTNRANKOMST = $6;
	my $IDENTMERKING = $7;
	my $VEKTSTREKKODE = $8; # Not used, always 000
	my $LOPENR = $9; # Not user, always 0000000
	my $IDENTTABLAPROD = $10;

	my %result = (
		"carrier_type_suggestion" => $LB, # Note : Set suggestion only
		#"carrier_measuringpoint_postcode_id" => $MP_IDPO,
		#"carrier_measuringpoint_user_id" => $MP_IDPO . $MP_IDMP,
		#"carrier_measuringpoint_id" => $MP_IDMP,
		"source_meetingpoint_user_id_suggestion" => zerotrim($MP_IDPO . $MP_IDMP),
		"source_meetingpoint_user_id" => zerotrim($MP_IDPO . $MP_IDMP),
		"product_params" => $PRODUCTPARAMS,
		"marking_postcode_id" => $POSTNRANKOMST,
		"marking_id" => $IDENTMERKING,
		"transportation_type" => $IDENTTABLAPROD
	);

	return \%result;
}

sub process_barcode_2X {
	my $barcode = shift;

	# 2X8 00203511214100207462700000092193

	if ($barcode !~ /^(2X)(\d)(\d{4})(\d{3})(\d{5})(\d{4})(\d{5})(000000)(\d{4})(\d{1})$/) {
		return undef;
	}

	my $KODEPREFIKS = $1;
	my $LB = $2;
	my $MP_IDPO = $3;
	my $MP_IDMP = $4;
	my $PRODUCTPARAMS = $5;
	my $POSTNRANKOMST = $6;
	my $IDENTMERKING = $7;
	my $VEKTSTREKKODE = $8; # Not used, always 000000
	my $IDENTTABLA = $9;
	my $IDENTTABLAPROD = $10;

	my %result = (
		"carrier_type_suggestion" => $LB, # Note : Set suggestion only
		#"carrier_measuringpoint_postcode_id" => $MP_IDPO,
		#"carrier_measuringpoint_user_id" => $MP_IDPO . $MP_IDMP,
		#"carrier_measuringpoint_id" => $MP_IDMP,
		"source_meetingpoint_user_id_suggestion" => zerotrim($MP_IDPO . $MP_IDMP),
		"source_meetingpoint_user_id" => zerotrim($MP_IDPO . $MP_IDMP),
		"product_params" => $PRODUCTPARAMS,
		"marking_postcode_id" => $POSTNRANKOMST,
		"tableau_id" => $IDENTTABLA,
		"marking_id" => $IDENTMERKING,
		"transportation_type" => $IDENTTABLAPROD
	);

	return \%result;
}

sub process_barcode_3Y_4Y {
	my $barcode = shift;

	# 4Y6 00201181214080002282900000000213

	if ($barcode !~ /^([34]Y)(\d)(\d{4})(\d{3})(\d{5})(\d{4})(\d{5})(\d{3})(\d{7})(\d{1})$/) {
		return undef;
	}

	my $KODEPREFIKS = $1;
	my $LB = $2;
	my $MP_IDPO = $3;
	my $MP_IDMP = $4;
	my $PRODUCTPARAMS = $5;
	my $POSTNRANKOMST = $6;
	my $IDENTMERKING = $7;
	my $VEKTSTREKKODE = $8; # Not used, always 000
	my $LOPENR = $9;
	my $IDENTMEFO = $10;

	my %result = (
		"carrier_type" => $LB,
		"carrier_type_suggestion" => $LB,
		# NOTE ! 3Y/4Y have meetingpoint in the barcode
		"carrier_measuringpoint_postcode_id" => $MP_IDPO,
		"carrier_measuringpoint_user_id" => $MP_IDPO . $MP_IDMP,
		"carrier_measuringpoint_id" => $MP_IDMP,
		"source_meetingpoint_user_id_suggestion" => zerotrim($MP_IDPO . $MP_IDMP),
		"source_meetingpoint_user_id" => zerotrim($MP_IDPO . $MP_IDMP),
		"product_params" => $PRODUCTPARAMS,
		"marking_postcode_id" => $POSTNRANKOMST,
		"marking_id" => $IDENTMERKING,
		"serial" => $LOPENR,
		"marking_property_short" => $IDENTMEFO,
		"transportation_type" => "0"
	);

	return \%result;
}

sub process_barcode_LKK2_LKTK {
	my $barcode = shift;

	# LK K2 6 12161 0 2 1FF30 0020351
	# LK K2 7 42940 0 1 04BB6 0020351
	# LK K2 6 12159 0 4 0D922 0020434
	# LK TK 6 12159 0 4 0D922 0020434
	if ($barcode !~ /^LK(K2|TK)(\d)(\d{5})(\d)(\d)(\w{5})(\d{7})$/) {
		return undef;
	}
	
	# $1 not needed here
	my $LB = $2;
	my $PRODUCTPARAMS = $3;
	my $XXX = $4; # Always 0
	my $IDENTTABLAPROD = $5; # Bad name for transportation type
	my $IDENTMERK_HEX = $6;
	my $FRASTED = $7;

	my %result = (
		"marking_id" => hex_to_dec($IDENTMERK_HEX),
		"product_params" => $PRODUCTPARAMS,
		"transportation_type" => $IDENTTABLAPROD,
		"carrier_type_suggestion" => $LB, # Note : Set suggestion only
		"source_meetingpoint_user_id_suggestion" => zerotrim($FRASTED)
	);

	return \%result;
}

sub process_barcode_LKKK {
	my $barcode = shift;

	# LK KK 8 12191 0 0 102E1
	if ($barcode !~ /^LKKK(\d)(\d{5})(\d)(\d)(\w{4}\w?)$/) {
		return undef;
	}

	my $LB = $1;
	my $PRODUCTPARAMS = $2;
	my $XXX = $3; # Always 0
	my $IDENTTABLAPROD = $4; # Bad name for transportation type
	my $IDENTMERK_HEX = $5; # Can be zerofilled 4 (buggy client) or 5 characters

	my %result = (
		"marking_id" => hex_to_dec($IDENTMERK_HEX),
		"product_params" => $PRODUCTPARAMS,
		"transportation_type" => $IDENTTABLAPROD,
		"carrier_type_suggestion" => $LB
	);

	return \%result;
}

sub process_barcode_LK {
	my $barcode = shift;
	
	if ($barcode =~ /^LK(K2|TK)/) {
		return process_barcode_LKK2_LKTK($barcode);
	}
	elsif ($barcode =~ /^LKKK/) {
		return process_barcode_LKKK($barcode);
	}

	return undef;
}

sub process_barcode_LB {
	my $barcode = shift;

	# Don't return parameters to complete expand-barcode call, it must
	# be called again after we receive the translated barcode

	my %result = (
		'lb_lookup_barcode' => $barcode
	);

	return \%result;
}

sub process_barcode_TA {
	my $barcode = shift;

	if ($barcode !~ /^(TA)(\d{4})(\d{3})(\d{4})$/) {
		return undef;
	}

	my $PREFIX = $1;
	my $MP_IDMP = $2 . $3;
	my $SUFFIX = $4;

	my %result = (
		'timereg_prefix' => $PREFIX,
		'timereg_meetingpoint_user_id' => $MP_IDMP,
		'timereg_suffix' => $SUFFIX,
		'twostep_start' => "yes"
	);

	return \%result;
}

sub process_barcode_FN {
	my $barcode = shift;

	if ($barcode !~ /^(FN)(\d{6})$/) {
		return undef;
	}

	my $PREFIX = $1;
	my $SUBJECT = $2;

	my %result = (
		'timereg_subject_prefix' => $PREFIX,
		'timereg_subject' => $SUBJECT,
		'timereg_code_day' => "0",
		'timereg_code_month' => "0",
		'timereg_code_year' => "0",
		'timereg_code_valid' => "0"
	);

	return \%result;
}

sub process_barcode_FU {
	my $barcode = shift;

	if ($barcode !~ /^(FU)(\d{6})(\d\d)(\d\d)(\d\d)(\d)$/) {
		return undef;
	}

	my $PREFIX = $1;
	my $SUBJECT = $2;
	my $DAY = $3;
	my $MONTH = $4;
	my $YEAR = $5;
	my $VALID = $6;

	# Valid codes:
	# - 0: Always
	# - 1: Valid one day
	# - 2: Valid 2-7 days
	# - 3: Valid 8-14 days
	# - 9: Valid 14-28 days

	my %result = (
		'timereg_subject_prefix' => $PREFIX,
		'timereg_subject' => $SUBJECT,
		'timereg_code_day' => $DAY,
		'timereg_code_month' => $MONTH,
		'timereg_code_year' => $YEAR,
		'timereg_code_valid' => $VALID
	);

	return \%result;
}

sub process_barcode_LS {
	my $barcode = shift;

	if ($barcode !~ /^LS(SLETT|ALLE|KVOT)(\d*)$/) {
		print_error("Unknown LS-barcode $barcode\n");
		return undef;
	}

	my $PREFIX = "LS";
	my $COMMAND = $1;
	my $ARGUMENT = $2;

	if ($COMMAND eq "ALLE") {
		return {
			'twostep_start' => "no",
			'tableau_start' => "yes",
			"tableau_id" => $ARGUMENT
		};
	}
	else {
		return {
			'twostep_start' => "yes",
			'twostep_command' => "$COMMAND"
		};
	}
}

sub process_barcode {
	my $barcode = shift;

	my $ret = undef;
	my $code_prefix = "";
	if ($barcode =~ /^LK(\w\w)/) {
		$ret = process_barcode_LK($barcode);
		$code_prefix = "$1";
	}
	elsif ($barcode =~ /^LB\d+NO$/) {
		$ret = process_barcode_LB($barcode);
		$code_prefix = "LB";
	}
	elsif ($barcode =~ /^([34]Y)/) {
		$ret = process_barcode_3Y_4Y($barcode);
		$code_prefix = $1;
	}
	elsif ($barcode =~ /^([15]Y)/) {
		$ret = process_barcode_1Y_5Y($barcode);
		$code_prefix = $1;
	}
	elsif ($barcode =~ /^2Y/) {
		$ret = process_barcode_2Y($barcode);
		$code_prefix = "2Y";
	}
	elsif ($barcode =~ /^2X/) {
		$ret = process_barcode_2X($barcode);
		$code_prefix = "2X";
	}
	elsif ($barcode =~ /^TA/) {
		$ret = process_barcode_TA($barcode);
		$code_prefix = "TA";
	}
	elsif ($barcode =~ /^FN/) {
		$ret = process_barcode_FN($barcode);
		$code_prefix = "FN";
	}
	elsif ($barcode =~ /^FU/) {
		$ret = process_barcode_FU($barcode);
		$code_prefix = "FN";
	}
	elsif ($barcode =~ /^LS/) {
		$ret = process_barcode_LS($barcode);
		$code_prefix = "LS";
	}

	if (defined $ret) {
		$ret->{'code_prefix'} = $code_prefix;
		$ret->{'barcode_orig'} = $barcode;
	}

	return $ret;
}

sub check_and_save_reading {
	my $argument_hash = shift;
	my $key_in = shift;

	my $target_cache = shift;
	my $key_out_a = shift;
	my $key_out_b = shift;

	my $debug_name = shift;

	my $something_found = 0;

	if (is_nonempty ($argument_hash, $key_in)) {
		if ($argument_hash->{$key_in} !~ /^(\d+)(|\.(\d+))$/) {
			print_error("Invalid reading $argument_hash->{$key_in} in parameter $key_in from $key_out_a\n");
		}
		else {
			$something_found = 1;
			cache_push ($target_cache, $key_out_a, $key_out_b, $argument_hash->{$key_in});
			if ($DEBUG_READINGS) {
				print_info("Reading $debug_name $key_out_a " . $argument_hash->{$key_in} . "\n")
			}
		}
	}

	return $something_found;
}	

sub treat_reading {
	my $reading = shift;

	$reading =~ s/[\s\+]//g;

	if ($reading =~ /^(\d+)([\.,]\d+|)$/) {
		# OK, kg with decimals type reading
	}
	elsif ($reading =~ /(\d+)g/) {
		# OK, gram type reading
		$reading = $1 / 1000;
	}
	else {
		return undef;
	}

	return $reading;
}

sub print_missing_values {
	my $values = shift;
	my $method = shift;

	my $missing_text = "";

	foreach my $key (@{$global_api_matrix{$method}->{'inputs'}}) {
		if (!defined ($values->{$key})) {
			$missing_text .= "- $key\n";
		}
	}

	print_error("Values missing for $method:\n$missing_text\n");
}

sub send_incrementer_id_messages {
	my $message = shift;
	my $argument_hash = shift;
	my $class = shift;

	# Ensure that incrementer is initialized with the latest known ID. It will ignore
	# this message if the given measuringpoint is already initialized.
	$message->{'topic'} = $global_settings->{'lbs_topic_incrementer_id_prefix'} . "/$class/$argument_hash->{'event_measuringpoint_user_id'}";
	$message->push_tag_str($global_settings->{'lbs_tag_incrementer_id_serial'}, $argument_hash->{'latest_serial'});
	$message->send();

	# Retrieve a new ID, send an empty message with the same incrementer topic set, but without the serial parameter.
	# Message ID is used for return value matching.
	# Before enrichment with the result, the process function will extract the serial from
	# the topic incrementer made and set the "serial" parameter.
	$message->clear_array();
	$message->push_tag_str("message_id", $argument_hash->{'message_id'});
	$message->send();
}

sub send_incrementer_quotient_counter_message {
	my $message = shift;
	my $argument_hash = shift;

	$message->{'topic'} = $global_settings->{'lbs_topic_incrementer_quotient_counter_prefix'} .
		"/$argument_hash->{'carrier_measuringpoint_postcode_id'}" .
		"/$argument_hash->{'product_params_group'}" .
		"/$argument_hash->{'product_params_service_level'}" .
		"/$argument_hash->{'product_params_product'}" .
		"/$argument_hash->{'product_params_format'}" .
		"/$argument_hash->{'product_params_process_degree'}" .
		"/$argument_hash->{'marking_property_short'}";
	$message->clear_array();
	$message->push_tag_str("message_id", $argument_hash->{'message_id'});
	$message->send();
}

sub process_api_request {
	my $message = shift;
	my $cache_message = shift;
	my $method = shift;
	my $argument = shift;
	my $argument_hash = shift;
	my $activate_groups_array = shift;
	my $api_call_hashref_queue = shift;
	my $endpoint_override = shift;

	$message->clear_array();
	$message->ip_clear();

	# First check for local hooks, API request we resolve here. Other
	# requests goes to external API module
	if ($method eq "lbs/print-timeout-message") {
		my $timeout_s = $global_settings->{'lbs_enrichment_timeout'} * 0.90;
		if (tv_interval($argument_hash->{'gettimeofday_process'}) > $timeout_s) {
			print_error("Message timeout\n");
			return { "print_timeout_message_performed" => "yes", "saved" => "error" };
		}

		my $done_count = 0;
		my $done_target = 1;

		if (is_set($argument_hash, 'saved')) {
		       $done_count++;
		}
		if (is_yes($argument_hash, 'push_service_performed')) {
		       $done_count++;
		}
		if (is_yes($argument_hash, 'print_decition')) {
			$done_target++;
			if (is_set($argument_hash, 'printed')) {
				$done_count++;
			}
		}
		if ($done_count >= $done_target) {
			return {
				'debug_missing_values_done' => "yes",
				"print_timeout_message_performed" => "no"
			};
		}
	}
	elsif ($method eq "lbs/debug-missing-values") {
		my $timeout_s = $global_settings->{'lbs_enrichment_timeout'} * 0.75;
		if (tv_interval($argument_hash->{'gettimeofday_process'}) > $timeout_s) {
			if ($DEBUG_MISSING_VALUES) {
				foreach my $method (keys(%global_api_matrix)) {
					my $rule = $global_api_matrix{$method};
	
					if (!enrichment_rule_check_need_execute($cache_message, $rule, 0)) {
						next;
					}

					print_missing_values($argument_hash, $method);
				}

				my $values = "Dumping values:\n";
				foreach my $key (sort keys %{$argument_hash}) {
					$values .= "- '$key' => '$argument_hash->{$key}'\n";
				}
				print_error($values);
			}

			return { 'debug_missing_values_done' => "yes" };
		}
	}
	elsif ($method eq "lbs/machine-scanner-ensure") {
		my %result = ();
		# Define missing values for non-used measuringpoint types
		if (!is_nonzero($argument_hash, 'machine')) {
			$result{'machine'} = "";
		}
		if (!is_nonempty($argument_hash, 'scanner_ip')) {
			$result{'scanner_ip'} = "";
		}
		if (!is_nonempty($argument_hash, 'scanner_port')) {
			$result{'scanner_port'} = "";
		}
		return \%result;
	}
	elsif ($method eq "lbs/machine-scanner-check") {
		if (is_nonzero($argument_hash, 'machine')) {
			push @{$activate_groups_array}, "lbs-printmachine";
		}
		else {
			push @{$activate_groups_array}, "lbs-identscanner";
		}
		return {"machine_scanner_checked" => "yes"};
	}
	elsif ($method eq "lbs/cancel-id-ensure") {
		return { "cancel_id" => "0" };
	}
	elsif ($method eq "lbs/cancel-check") {
		if (!is_yes($argument_hash, "cancel")) {
			return { "cancel_performed" => "no" };
		}

		# We will delete ourselves, set counter to -1 to ignore this
		my $i = -1;
		for my $key (keys(%global_enrichment_cache)) {
			if (is_equal_to($global_enrichment_cache{$key}, "cancel_id", $argument_hash->{'cancel_id'})) {
				delete $global_enrichment_cache{$key};
				$i++;
			}
		}
		for (my $i = 0; $i < @global_enrichment_input_queue; $i++) {
			if (is_equal_to($global_enrichment_input_queue[$i], "cancel_id", $argument_hash->{'cancel_id'})) {
				splice (@global_enrichment_input_queue, $i, 1);
				$i++;
			}
		}

		if ($i > 0) {
			print_info("Deleted $i message" . ($i == 1 ? "" : "s") . " while processing cancel command with ID '$argument_hash->{'cancel_id'}'\n");
		}

		return { "cancel_performed" => "yes" };
	}
	elsif ($method eq "lbs/group-lbs-check") {
		if (is_no($argument_hash, 'reading_performed') and
		    is_no($argument_hash, 'push_service_performed') and
		    is_no($argument_hash, 'cancel_performed')
	        ) {
			push @{$activate_groups_array}, "lbs";
		}
		return { 'group_lbs_checked' => "yes" };
	}
	elsif ($method eq "lbs/group-lbs-selection") {
		my $did_select = 0;

		if (is_equal_to($argument_hash, "code_prefix", "error") or
		    is_equal_to($argument_hash, "twostep_start", "error")
		) {
			return { 'group_selected' => "no" };
		}
		elsif (is_yes($argument_hash, 'twostep_start')){
			push @{$activate_groups_array}, "twostep";
			$did_select = 1;
		}
		elsif (is_yes($argument_hash, 'tableau_start')){
			push @{$activate_groups_array}, "tableau";
			$did_select = 1;
		}
		elsif (is_nonzero($argument_hash, 'code_prefix')) {
			if ($argument_hash->{'code_prefix'} =~ /^F[NU]$/) {
				push @{$activate_groups_array}, "timereg";
			}
			else {
				push @{$activate_groups_array}, "carrier-twostep-lookup";
			}
			$did_select = 1;
		}
		if ($did_select) {
			return { 'group_selected' => "yes" };
		}
	}
	elsif ($method eq "lbs/explode-tableau") {
		my %template;

		foreach my $key (qw/scanner_ip scanner_port command_source source_meetingpoint_user_id_suggestion transportation_type carrier_type_suggestion product_params code_prefix weight twostep_start/) {
			if (is_nonempty($argument_hash, $key)) {
				$template{$key} = $argument_hash->{$key};
			}
		}

		my @marking_ids = split(/\s*,\s*/, $argument_hash->{'marking_ids'});

		print_info_ident("Exploding tableau $argument_hash->{'tableau_id'} (" . (scalar @marking_ids) . " markings)\n", $argument_hash->{'event_measuringpoint_user_id'});

		my $seq = 1;
		foreach my $marking_id (@marking_ids) {
			my %cache_message = %template;
			$cache_message{'code_prefix'} = "K2";
			$cache_message{'marking_id'} = $marking_id;
			$cache_message{'sequence'} = $seq++;
			enrichment_cache_queue(\%cache_message);
		}

		return { "saved" => "yes" };
	}
	elsif ($method eq "lbs/expand-touch-tidreg") {
		return {
			'code_prefix' => "TA",
			'timereg_prefix' => "TA",
			'timereg_meetingpoint_user_id' => $argument_hash->{'tidreg_mpid'},
			'timereg_suffix' => "1000",
			'twostep_start' => "yes"
		};
	}
	elsif ($method eq "lbs/expand-touch-twostep-command") {
		return {
			'code_prefix' => "LS",
			'twostep_start' => "yes"
		};
	}
	elsif ($method eq "lbs/expand-touch-carrier") {
		return {
			'twostep_start' => "no",
			'code_prefix' => "K2"
		};
	}
	elsif ($method eq "lbs/expand-touch-tableau") {
		return {
			'tableau_start' => "yes",
			'twostep_start' => "no",
			'code_prefix' => "K2"
		};
	}
	elsif ($method eq "lbs/twostep-start") {
		# Noisy message
		#print_info("Twostep started, key is $argument_hash->{'scanner_ip'}:$argument_hash->{'scanner_port'}\n");
		cache_push_hashref(\%global_twostep_cache, "$argument_hash->{'scanner_ip'}:$argument_hash->{'scanner_port'}", $argument_hash);
		return {
			'twostep_started' => "yes",
			'saved' => "yes"
		};
	}
	elsif ($method eq "lbs/get-print-decition") {
		my $decition = "no";

		if ( $argument_hash->{'code_prefix'} =~ /^KK|K2|TK|2Y|2X|LB|BS$/ and
		     $argument_hash->{'carrier_twostep_command'} eq "none"
		) {
			$decition = "yes";
		}

		return { 'print_decition' => $decition };
	}
	elsif ($method eq "lbs/set-client-requirements") {
		return {
			"carrier_type_enforce" => $argument_hash->{'client_type'} eq "FLOOR" ? "yes" : "no",
			"tare_weight_enforce" => $argument_hash->{'client_type'} eq "FLOOR" ? "yes" : "no"
		};
	}
	elsif ($method eq "lbs/set-zero-chute-name") {
		return { 'chute_name' => '0' };
	}
	elsif ($method eq "lbs/set-client-name") {
		return { "client_name" => $global_settings->{'lbs_fake_hostname'} };
	}
	elsif ($method eq "lbs/set-unix-timestamp") {
		return {
			'datestring_unix' => time
		};
	}
	elsif ($method eq "lbs/set-lbs-timestamp") {
		return {
			'datestring_lbs' => get_lbs_datestring(get_localtime_array($argument_hash->{'datestring_unix'}))
		};
	}
	elsif ($method eq "lbs/set-internal-timestamp") {
		return {
			'datestring_gettimeofday' => [gettimeofday]
		};
	}
	elsif ($method eq "lbs/set-command-source") {
		return { "command_source" => "OTHER" };
	}
	elsif ($method eq "lbs/set-weekday") {
		return {
			'weekday' => get_weekday(get_localtime_array($argument_hash->{'datestring_unix'}))
		};
	}
	elsif ($method eq "lbs/check-print-wait-ignore") {
		if (is_yes($argument_hash, 'reading_performed') or
		    is_no($argument_hash, 'printed') or
		    is_equal_to($argument_hash, "code_prefix", "error") or
		    is_equal_to($argument_hash, "twostep_start", "error")
		) {
			return { "print_wait_ignore" => "yes" };
		}
		# Tag messages to be ignored when assessing print wait just before they time out
		my $timeout_ms = $global_settings->{'lbs_enrichment_timeout'} * 1000 * 0.75;
		my $diff = 1000 * tv_interval $argument_hash->{'datestring_gettimeofday'}, [gettimeofday];
		if ($diff > $timeout_ms) {
			return { "print_wait_ignore" => "yes" };
		}
	}
	elsif ($method eq "lbs/set-print-wait-ignore") {
		return { "print_wait_ignore" => "yes" };
	}
	elsif ($method eq "lbs/carrier-twostep-lookup") {
		my %result = (
			'carrier_twostep_command' => "none",
			'carrier_twostep_command_reprocess' => "none"
		);

		my $key = "$argument_hash->{'scanner_ip'}:$argument_hash->{'scanner_port'}";
		my $twostep_command = undef;

		if (is_nonempty($argument_hash, 'carrier_twostep_command_reprocess')) {
			$twostep_command = $argument_hash->{'carrier_twostep_command_reprocess'};
		}
		else {
			my $cache_msg = cache_lookup_hashref(\%global_twostep_cache, $key);
			if (defined $cache_message and is_nonempty($cache_msg, 'twostep_command')) {
				$twostep_command = $cache_msg->{'twostep_command'};
			}
		}

		if (!defined $twostep_command or $twostep_command eq "none") {
			# OK, no cache message present
			push @{$activate_groups_array}, "carrier";
		}
		elsif (is_nonempty($argument_hash, 'code_prefix') and (
			$argument_hash->{'code_prefix'} eq "1Y" or
			$argument_hash->{'code_prefix'} eq "3Y" or
			$argument_hash->{'code_prefix'} eq "4Y"
		)) {
			# OK, valid barcode for twostep command
			cache_clear(\%global_twostep_cache, $key);
			push @{$activate_groups_array}, "carrier";
			$result{'carrier_twostep_command'} = $twostep_command;
		}
		else {
			if (is_nonempty($argument_hash, 'carrier_twostep_command_reprocess')) {
				print_error("Twostep reprocess loop detected for command '$twostep_command'\n");
				$result{'saved'} = "error";
				return \%result;
			}

			# OK, expect twostep reprocessing
			cache_clear(\%global_twostep_cache, $key);
			push @{$activate_groups_array}, "carrier";
			$result{'carrier_twostep_command_reprocess'} = $twostep_command;
		}

		return \%result;
	}
	elsif ($method eq "lbs/get-self-source-meetingpoint-suggestion") {
		my %result = (
			"source_meetingpoint_suggestion_checked" => "yes"
		);
		if ($argument_hash->{'code_prefix'} eq "KK" or $argument_hash->{'code_prefix'} eq "BS") {
			$result{'source_meetingpoint_user_id_suggestion'} = $argument_hash->{'event_meetingpoint_user_id'};
		}
		return \%result;
	}
	elsif ($method eq "lbs/check-tableau-id-precence") {
		if (is_nonzero ($argument_hash, "tableau_id")) {
			push @{$activate_groups_array}, "carrier-tableau-known";
		}
		else {
			push @{$activate_groups_array}, "carrier-tableau-unknown";
		}
		return { "tableau_id_precence_checked" => "yes" };
	}
	elsif ($method eq "lbs/set-zero-label-group-id") {
		return { "label_group_id" => "0" };
	}
	elsif ($method eq "lbs/group-marking-check") {
		if (	is_nonzero ($argument_hash, 'source_meetingpoint_user_id_suggestion') and
			$argument_hash->{'transportation_type'} ne "no-xmrk"
		) {
			push @{$activate_groups_array}, "carrier-xmrk";
		}
		else {
			push @{$activate_groups_array}, "carrier-marking";
		}
		return { "group_marking_checked" => "yes" };
	}
	elsif ($method eq "lbs/trim-marking-property") {
		if ($argument_hash->{'marking_property_long'} =~ /^(\d)(\d*)$/) {
			return { "marking_property_short" => $1 };
		}

		print_error("Invalid value '$argument_hash->{'marking_property_long'}' for parameter 'marking_property_long' encountered, value must be one or more digits\n");
	}
	elsif ($method eq "lbs/deduct-transport-method") {
		my $result = "7"; # Default value

		if ($argument_hash->{'transportation_type'} eq "1") {
			$result = "2";
		}
		elsif ($argument_hash->{'transportation_type'} eq "5") {
			$result = "8";
		}

		return { "transport_method" => $result };
	}
	elsif ($method eq "lbs/set-source-meetingpoint-min-max") {
		my $s = $argument_hash->{"source_meetingpoint_user_id_suggestion"};
		my $min = $s;
		my $max = $s;

		if ($argument_hash->{'transportation_type'} eq "0") {
			$min = $s - ($s % 1000) + 100;
			$max = $s - ($s % 1000) + 999;
		}

		return {
			"source_meetingpoint_user_id_min" => $min,
			"source_meetingpoint_user_id_max" => $max
		};
	}
	elsif ($method eq "lbs/debug-xmarking") {
		if ($argument_hash->{'transportation_type'} eq "nonzero") {
			print_info_ident("Get XMRK IDENTMERKING $argument_hash->{'marking_id'} $argument_hash->{'source_meetingpoint_user_id_max'}>=FRASTED>=$argument_hash->{'source_meetingpoint_user_id_min'} IDENTTABLAPROD<>0\n", $argument_hash->{'event_measuringpoint_user_id'});
		}
		else {
			print_info_ident("Get XMRK IDENTMERKING $argument_hash->{'marking_id'} $argument_hash->{'source_meetingpoint_user_id_max'}>=FRASTED>=$argument_hash->{'source_meetingpoint_user_id_min'} IDENTTABLAPROD=$argument_hash->{'transportation_type'}\n", $argument_hash->{'event_measuringpoint_user_id'});
		}
		return { "debug_xmarking_done" => "yes" };
	}
	elsif ($method eq "lbs/deduct-xmarking-source-meetingpoint") {
		my %result;
		if ($argument_hash->{'transportation_type'} eq "0") {
			$result{ "source_meetingpoint_user_id"} = $argument_hash->{'source_meetingpoint_user_id_suggestion'};
		}
		else {
			$result{ "source_meetingpoint_user_id"} = $argument_hash->{'source_meetingpoint_user_id_xmarking'};
		}
		return \%result;
	}
	elsif ($method eq "lbs/debug-marking") {
		print_info_ident("Get MRK IDENTMERKING $argument_hash->{'marking_id'}\n", $argument_hash->{'event_measuringpoint_user_id'});
		return { "debug_marking_done" => "yes" };
	}
	elsif ($method eq "lbs/increment-serial-carrier") {
		send_incrementer_id_messages($message, $argument_hash, "carrier");
		# This function returns nothing immediately
	}
	elsif ($method eq "lbs/increment-serial-timereg") {
		send_incrementer_id_messages($message, $argument_hash, "timereg");
		# This function returns nothing immediately
	}
	elsif ($method eq "lbs/get-self-carrier-measuringpoint") {
		if ($argument_hash->{'code_prefix'} eq "LB") {
			return undef;
		}
		my %result = (
			'carrier_measuringpoint_id' => $argument_hash->{'event_measuringpoint_id'},
			'carrier_measuringpoint_postcode_id' => $argument_hash->{'event_measuringpoint_postcode_id'},
			'carrier_measuringpoint_user_id' => $argument_hash->{'event_measuringpoint_user_id'}
		);
		return \%result;
	}
	elsif ($method eq "lbs/expand-irv") {
		$argument_hash->{'label'} =~ /^\d{4}(\d+)$/;
		my $marking_id = $1;

		return {
			"chute_name" => $argument_hash->{'stacker'},
			"transport_method" => $argument_hash->{'transportmethod'},
			"product_params_group" => "1", # Letters
			"product_params_product" => "1", # Letters
			"product_params_format" => "5", # Small
			"product_params_service_level" => $argument_hash->{'velocity'},
			"product_params_process_degree" => $argument_hash->{'processdegree'},
			"marking_id" => $marking_id,
			"transportation_type" => "0",
			"code_prefix" => "BS",
			"carrier_type" => 6, # Tray
			"carrier_type_suggestion" => 6, # Tray
			"twostep_start" => "no"
		};
	}
	elsif ($method eq "lbs/expand-telegram") {
		$argument_hash->{'LABELID'} =~ /^\d{4}(\d+)$/;
		my $marking_id = $1;

		return {
			"chute_name" => $argument_hash->{'OUTPUT'},
			"transport_method" => $argument_hash->{'TRANSPORTMETHOD'},
			"product_params_group" => $argument_hash->{'PRODUCTGROUP'},
			"product_params_product" => $argument_hash->{'PRODUCT'},
			"product_params_format" => $argument_hash->{'FORMAT'},
			"product_params_service_level" => $argument_hash->{'SERVICELEVEL'},
			"product_params_process_degree" => $argument_hash->{'PROCESSLEVEL'},
			"marking_id" => $marking_id,
			"transportation_type" => "0",
			"code_prefix" => "BS",
			"carrier_type" => $argument_hash->{'CARRIERTYPE'},
			"carrier_type_suggestion" => $argument_hash->{'CARRIERTYPE'},
			"twostep_start" => "no"
		};
	}
	elsif ($method eq "lbs/expand-palletmani") {
		my %result = (
			"chute_name" => $argument_hash->{'cellid'},
			"transport_method" => $argument_hash->{'transportmethod'},
			"product_params_product" => $argument_hash->{'product'},
			"product_params_format" => $argument_hash->{'format'},
			"product_params_service_level" => $argument_hash->{'velocity'},
			"product_params_process_degree" => $argument_hash->{'processdegree'},
			"marking_id" => $argument_hash->{'label'},
			"carrier_type" => $argument_hash->{'carriertype'},
			"carrier_type_suggestion" => $argument_hash->{'carriertype'},
			"tare_weight" => $argument_hash->{'unladenweight'},
			"tray_count" => $argument_hash->{'elements'},
			"weight" => $argument_hash->{'weight'},
			"product_params_group" => "1", # Letters
			"transportation_type" => "0",
			"code_prefix" => "BS",
			"twostep_start" => "no"
		);

		if ($result{'weight'} < $result{'tare_weight'}) {
			$result{'weight'} = $result{'tare_weight'};
		}

		print_info ("Print request for label $result{'marking_id'} from cell ID $result{'chute_name'}. Weight is $result{'weight'}.\n");

		return \%result;
	}
	elsif ($method eq "lbs/check-reading") {
		if ( !is_nonempty ($argument_hash, 'scanner_ip') or
		     !is_nonempty ($argument_hash, 'scanner_port') # May be 0
	        ) {
			return { "reading_performed" => "no" };
		}

		my $key = "$argument_hash->{'scanner_ip'}:$argument_hash->{'scanner_port'}";

		my $something_found = 0;

		my $reading_stable = undef;

		if (is_nonempty ($argument_hash, 'reading_stable')) {
			$reading_stable = $argument_hash->{'reading_stable'};
		}
		elsif (is_equal_to ($argument_hash, 'reading_prefix', "S") and is_nonempty ($argument_hash, 'reading')) {
			$reading_stable = $argument_hash->{'reading'};
		}

		if (defined $reading_stable) {
			$something_found = 1;

			my $reading;

			if (!defined ($reading = treat_reading($reading_stable))) {
				print_error("Invalid stable reading '$reading_stable' received for '$key', ignoring\n");
			}
			else {
				cache_push (\%global_weight_stable_cache, "$key", "weight_stable", $reading);

				if ($DEBUG_READINGS) {
					print_info("Reading Stable Weight $key $reading\n");
				}
			}
		}

		if (is_nonempty ($argument_hash, 'reading')) {
			$something_found = 1;

			my $reading;

			if (!defined ($reading = treat_reading($argument_hash->{'reading'}))) {
				print_error("Invalid weight reading '$argument_hash->{'reading'}' received for '$key', ignoring\n");
				$reading = 0;
			}

			if ($reading > 0) {
				cache_push (\%global_weight_cache, "$key", "weight", $reading);

				my @readings_new;

				my $record_old = cache_lookup_hashref(\%global_weight_history_cache, $key);
				if (defined ($record_old)) {
					foreach my $reading_ref (@{$record_old->{'readings'}}) {
						if (tv_interval($reading_ref->{'timestamp'}) > $STABLE_WEIGHT_CHECK_PERIOD) {
							next;
						}
						push @readings_new, $reading_ref;
					}
				}

				push @readings_new, {
					"weight" => $reading,
					"timestamp" => [gettimeofday]
				};

				my %record_new = (
					"readings" => \@readings_new
				);

				cache_push_hashref(\%global_weight_history_cache, $key, \%record_new);

				if ($DEBUG_READINGS) {
					print_info("Reading Weight $key $reading\n");
				}
			}
		}

		$something_found |= check_and_save_reading($argument_hash, 'reading_tare', \%global_tare_weight_cache, $key, 'tare_weight', 'Tare Weight');
		$something_found |= check_and_save_reading($argument_hash, 'reading_carrier', \%global_carrier_type_cache, $key, 'carrier_type', 'Carrier Type');
		$something_found |= check_and_save_reading($argument_hash, 'reading_content', \%global_carrier_content_cache, $key, 'carrier_content_type', 'Carrier Content');
		$something_found |= check_and_save_reading($argument_hash, 'reading_count', \%global_carrier_content_count_cache, $key, 'carrier_content_count', 'Carrier Content Count');
		$something_found |= check_and_save_reading($argument_hash, 'reading_quotient_count', \%global_quotient_count_cache, $key, 'quotient_uptake_count', 'Carrier Content Count');

		if ($something_found) {
			return {
				"reading_performed" => "yes",
				"saved" => "yes",
				"no_push_notification" => "yes"
			};
		}

		return { "reading_performed" => "no" };
	}
	elsif ($method eq "lbs/push-service") {
		my $result = {
			"push_service_performed" => "no"
		};

		if (is_nonempty($argument_hash, 'scanner_ip') and is_nonempty($argument_hash, 'scanner_port')) {
			my $key = "$argument_hash->{'scanner_ip'}:$argument_hash->{'scanner_port'}";

			if (is_nonempty($argument_hash, 'push_service')) {
				cache_push (\%global_push_service_cache, $key, $argument_hash->{'push_service'}, 1);

				$result->{"push_service_performed"} = "yes";
				$result->{"saved"} = "no";
			}
			else {
				if (	is_nonempty($argument_hash, 'barcode') and
					defined cache_lookup (\%global_push_service_cache, $key, "grab_barcode")
				) {
					print_info ("Pushing received barcode to HTTP client '$key' as requested: '$argument_hash->{'barcode'}'\n");
					set_ip($message, $argument_hash->{'scanner_ip'}, $argument_hash->{'scanner_port'}, "tcp");
					send_barcode_push ($message, $argument_hash->{'barcode'});
	
					$result->{"push_service_performed"} = "yes";
					$result->{"saved"} = "yes";
				}
			}
		}

		return $result;
	}
	elsif ($method eq "lbs/expand-barcode") {
		my $result = {};
		$result = process_barcode($argument_hash->{'barcode'});
		if (!defined ($result)) {
			my $error_msg_from = (is_nonempty($argument_hash, 'scanner_ip') and is_nonempty($argument_hash, 'scanner_port'))
				? " from $argument_hash->{'scanner_ip'}:$argument_hash->{'scanner_port'}"
				: ""
			;
			if ($argument_hash->{'barcode'} eq "\x18") {
				print_error("Received no-read indicator 0x18$error_msg_from\n");
			}
			else {
				print_error("Received invalid barcode '$argument_hash->{'barcode'}'$error_msg_from\n");
			}
			$result = {
				"code_prefix" => "error",
				"saved" => "error"
			};
		}
		if (!is_nonempty($result, 'twostep_start')) {
			$result->{'twostep_start'} = "no";
		}
		return $result;
	}
	elsif ($method eq "lbs/expand-print-barcode") {
		my $result = process_barcode($argument_hash->{'print_barcode'});
		if (!defined ($result)) {
			print_error("Received invalid print barcode '$argument_hash->{'print_barcode'}'\n");
			return undef;
		}
		return $result;
	}
	elsif ($method eq "lbs/get-print-barcode") {
		my $barcode = "";
		my $prefix = $argument_hash->{'code_prefix'};

		if ($prefix eq "TK") {
			$prefix = "5Y";
		}
		elsif ($prefix =~ /^2[XY]$/ or $prefix !~ /^[\d][XY]$/) {
			$prefix = "1Y";
		}

		$barcode .= $prefix;
		$barcode .= $argument_hash->{'carrier_type'};
		$barcode .= zerofill($argument_hash->{'carrier_measuringpoint_postcode_id'}, 4);
		$barcode .= zerofill($argument_hash->{'carrier_measuringpoint_id'}, 3);
		$barcode .= $argument_hash->{'product_params'};
		$barcode .= zerofill ($argument_hash->{'marking_postcode_id'}, 4);
		$barcode .= zerofill ($argument_hash->{'marking_id'}, 5);
		$barcode .= "000";
		$barcode .= zerofill($argument_hash->{'serial'}, 7);
		$barcode .= $argument_hash->{'marking_property_short'};

		return { 'print_barcode' => $barcode };
	}
	elsif ($method eq "lbs/set-tray-count") {
		if (is_nonempty($argument_hash, 'scale_ip') and is_nonempty($argument_hash, 'scale_port')) {
			my $key = "$argument_hash->{'scale_ip'}:$argument_hash->{'scale_port'}";
			my $carrier_content_type = cache_lookup_and_clear (\%global_carrier_content_cache, $key, "carrier_content_type");
			my $carrier_content_count = cache_lookup_and_clear (\%global_carrier_content_count_cache, $key, "carrier_content_count");

			if (defined $carrier_content_type and defined $carrier_content_count and $carrier_content_type eq "6") {
				return { "tray_count" => $carrier_content_count};
			}
		}
		# Return 1 if type is tray
		return { 'tray_count' => ($argument_hash->{'carrier_type'} eq "6" ? 1 : 0 ) };
	}
	elsif ($method eq "lbs/set-sequence") {
		return { "sequence" => "0" };
	}
	elsif ($method eq "lbs/quotient-uptake") {
		if (!is_yes($argument_hash, 'weight_check_complete')) {
			return { "quotient_decition" => "no"};
		}

		my $key = "$argument_hash->{'scale_ip'}:$argument_hash->{'scale_port'}";
		my $cache_msg = cache_lookup_hashref(\%global_quotient_count_cache, $key, "quotient_uptake_count");
		unless (defined $cache_msg and is_nonzero($cache_msg, 'quotient_uptake_count') and is_numeric($cache_msg, 'quotient_uptake_count')) {
			print_error_ident("Quotient count was not set or is not a positive number\n", $argument_hash->{'event_measuringpoint_user_id'});
			return { "quotient_decition" => "error"};
		}

		my $tare_weight = $argument_hash->{'tare_weight'} * 100;
		my $quotient_count = $cache_msg->{'quotient_uptake_count'};
		my $quotient_weight = $argument_hash->{'weight_grams'} - $tare_weight;

		unless ($quotient_weight > 0) {
			print_error_ident("Quotient weight was 0 (gross weight was $argument_hash->{'weight_grams'} tare weight was $tare_weight)\n", $argument_hash->{'event_measuringpoint_user_id'});
			return { "quotient_decition" => "error"};
		}

		my $quotient_measurement = 1000 / ($quotient_weight / $quotient_count);

		$quotient_measurement = ceil($quotient_measurement * 100) / 100;
		$quotient_measurement =~ s/\./,/;

		return {
			"quotient_uptake_measurement" => $quotient_measurement,
			"quotient_uptake_count" => $quotient_count,
			"quotient_uptake_weight" => $quotient_weight,
			"quotient_decition" => "yes"
		};
	}
	elsif ($method eq "lbs/debug-quotient-uptake") {
		if (is_yes($argument_hash, 'quotient_decition')) {
			print_info_ident("Quotient uptake carrier $argument_hash->{'barcode'} 1000/($argument_hash->{'quotient_uptake_weight'}/$argument_hash->{'quotient_uptake_count'}) = $argument_hash->{'quotient_uptake_measurement'} IDENTMEFO $argument_hash->{'marking_property_short'}\n", $argument_hash->{'event_measuringpoint_user_id'});
		}
		else {
			print_error_ident("Quotient uptake aborted\n", $argument_hash->{'event_measuringpoint_user_id'});
		}

		return { "debug_quotient_done" => "yes" };
	}
	elsif ($method eq "lbs/lookup-tare-weight") {
		if (is_nonempty($argument_hash, 'tare_weight')) {
			return {
				"tare_weight" => $argument_hash->{"tare_weight"},
				"tare_weight_is_from_message" => "yes"
			};
		}

		my %result = (
			"tare_weight_is_from_message" => "no"
		);

		if (!is_nonempty($argument_hash, 'scale_ip') or !is_nonempty($argument_hash, 'scale_port')) {
			return \%result;
		}

		my $key = "$argument_hash->{'scale_ip'}:$argument_hash->{'scale_port'}";
		my $tare_weight = cache_lookup_and_clear (\%global_tare_weight_cache, $key, "tare_weight");

		if (defined ($tare_weight)) {
			$result{"tare_weight"} = $tare_weight;
		}

		return \%result;
	}
	elsif ($method eq "lbs/set-tare-weight") {
		my %result = (
			"tare_weight_checked" => "yes"
		);

		if (!is_set($argument_hash, 'tare_weight')) {
			if ( is_yes($argument_hash, 'tare_weight_enforce') and
			    !is_yes($argument_hash, "weightless_command")
			) {
				print_error_ident("Tare weight was not set for floor client\n", $argument_hash->{'event_measuringpoint_user_id'});
				$result{'tare_weight'} = "missing";
			}
			else {
				$result{'tare_weight'} = $argument_hash->{'carrier_weight'};
			}
		}
		else {
			$result{'tare_weight'} = floor($argument_hash->{'tare_weight'} * 10);
		}

		if ($result{'tare_weight'} > 0 && $result{'tare_weight'} < $argument_hash->{'carrier_weight'} && $result{'tare_weight'} ne "missing") {
			print_error_ident("Tare weight was lower than carrier weight ($result{'tare_weight'}<$argument_hash->{'carrier_weight'})\n", $argument_hash->{'event_measuringpoint_user_id'});
			$result{'tare_weight'} = "missing";
		}

		return \%result;
	}
	elsif ($method eq "lbs/merge-product-params-carrier") {
		return { "product_params" => 
				$argument_hash->{'product_params_group'} .
				$argument_hash->{'product_params_service_level'} .
				$argument_hash->{'product_params_product'} .
				$argument_hash->{'product_params_format'} .
				$argument_hash->{'product_params_process_degree'}
		}
	}
	elsif ($method eq "lbs/expand-product-params-carrier") {
		if ($argument_hash->{'product_params'} =~ /^(\d)(\d)(\d)(\d)(\d)$/) {
			return {
				'product_params_group' =>  $1,
				'product_params_service_level' =>  $2,
				'product_params_product' =>  $3,
				'product_params_format' =>  $4,
				'product_params_process_degree' =>  $5
			};
		}
	}
	elsif ($method eq "lbs/expand-product-params-tidreg") {
		if ($argument_hash->{'timereg_suffix'} =~ /^(\d)(\d)(\d)(\d)$/) {
			return {
				'product_params_group' =>  $1,
				'product_params_product' =>  $2,
				'product_params_service_level' =>  $3,
				'product_params_format' =>  $4
			};
		}
	}
	elsif ($method eq "lbs/check-timereg-expiration") {
		if ($argument_hash->{'timereg_code_valid'} eq "0") {
			return { "timereg_expired" => "no" };
		}

		unless ($argument_hash->{'timereg_code_valid'} eq "1" or
		        $argument_hash->{'timereg_code_valid'} eq "2" or
		        $argument_hash->{'timereg_code_valid'} eq "3" or
		        $argument_hash->{'timereg_code_valid'} eq "9"
		) {
			print_error("Invalid time registration expiration parameter '$argument_hash->{'timereg_code_valid'}'");
			return { "timereg_expired" => "no" };
		}

		my $year_prefix = @{get_localtime_array()}[5];
		$year_prefix =~ s/^(\d+)\d\d$/$1/;

		my $code_timestamp = date_to_time (
			$argument_hash->{'timereg_code_day'},
			$argument_hash->{'timereg_code_month'},
			$year_prefix . $argument_hash->{'timereg_code_year'}
		);

		my $current_timestamp = time;

		if ($argument_hash->{'timereg_code_valid'} eq "1" and $code_timestamp + 24 * 3600 > $current_timestamp) {
			return { "timereg_expired" => "no" };
		}
		elsif ($argument_hash->{'timereg_code_valid'} eq "2" and $current_timestamp >= $code_timestamp + 24 * 3600 and $current_timestamp < $code_timestamp + 168 * 3600) {
			return { "timereg_expired" => "no" };
		}
		elsif ($argument_hash->{'timereg_code_valid'} eq "3" and $current_timestamp >= $code_timestamp + 168 * 3600 and $current_timestamp < $code_timestamp + 336 * 3600) {
			return { "timereg_expired" => "no" };
		}
		elsif ($argument_hash->{'timereg_code_valid'} eq "9" and $current_timestamp >= $code_timestamp + 336 * 3600 and $current_timestamp < $code_timestamp + 672 * 3600) {
			return { "timereg_expired" => "no" };
		}

		return { "timereg_expired" => "yes" };
	}
	elsif ($method eq "lbs/group-timereg-save-check") {
		if (is_no($argument_hash, 'timereg_expired')) {
			push @{$activate_groups_array}, "timereg-save";
		}
		else {
			return { "saved" => "no" };
		}
		return { "group_timereg_save_checked" => "no" };
	}
	elsif ($method eq "lbs/group-serial-check") {
		if ($argument_hash->{'code_prefix'} =~ /^1Y|LB|3Y|4Y|5Y|TA$/ or is_yes($argument_hash, 'twostep_start')) {
			# Do not activate serial groups
		}
		elsif ($argument_hash->{'code_prefix'} =~ /^F[NU]$/) {
			push @{$activate_groups_array}, "serial-timereg";
		}
		elsif ($argument_hash->{'code_prefix'} eq "error") {
			# Error, don't activate groups
		}
		else {
			push @{$activate_groups_array}, "serial-carrier";
		}
		return { 'group_serial_checked' => "yes" };
	}
	elsif ($method eq "lbs/lookup-carrier-type") {
		if (is_nonempty($argument_hash, 'carrier_type')) {
			return {
				"carrier_type" => $argument_hash->{"carrier_type"},
				"carrier_type_is_from_message" => "yes"
			};
		}

		my %result = (
			"carrier_type_is_from_message" => "no"
		);

		if (!is_nonempty($argument_hash, 'scale_ip') or !is_nonempty($argument_hash, 'scale_port')) {
			return \%result;
		}

		my $key = "$argument_hash->{'scale_ip'}:$argument_hash->{'scale_port'}";
		my $carrier_type = cache_lookup_and_clear (\%global_carrier_type_cache, $key, "carrier_type");

		if (defined ($carrier_type)) {
			$result{"carrier_type"} = $carrier_type;
		}

		return \%result;
	}
	elsif ($method eq "lbs/set-carrier-type") {
		my %result = (
			"carrier_type_is_from_message" => "no",
			"carrier_type_suggestion" => "done"
		);

		if (is_set($argument_hash, 'carrier_type')) {
			$result{'carrier_type'} = $argument_hash->{'carrier_type'};
		}
		elsif (is_yes($argument_hash, 'carrier_type_enforce')) {
			print_error_ident("Carrier type was not set for floor client\n", $argument_hash->{'event_measuringpoint_user_id'});
			return undef;
		}
		elsif (is_nonempty($argument_hash, 'carrier_type_suggestion')) {
			$result{'carrier_type'} = $argument_hash->{'carrier_type_suggestion'};
		}

		return \%result;
	}
	elsif ($method eq "lbs/group-carrier-quotient-check") {
		my %result = (
			"group_carrier_quotient_checked" => "yes"
		);

		if ($argument_hash->{'carrier_twostep_command'} eq "KVOT") {
			push @{$activate_groups_array}, "quotient-uptake";
		}
		elsif ($argument_hash->{'event_measuringpoint_type_name'} eq "KBA_ORDER_QUOTA") {
			push @{$activate_groups_array}, "carrier-quotient-divert-check";
			push @{$activate_groups_array}, "diverter";
		}
		else {
			$result{'quotient_decition'} = "no-quotient";
		}

		return \%result;
	}
	elsif ($method eq "lbs/group-carrier-quotient-count-check") {
		my %result = (
			"group_carrier_quotient_count_checked" => "yes"
		);

		if ($argument_hash->{'quotient_params_interval'} > 0) {
			push @{$activate_groups_array}, "carrier-quotient-count";
			print_info_ident("Carrier is eligible for quotient processing\n",
				$argument_hash->{'event_measuringpoint_user_id'});
		}
		else {
			print_info_ident("Carrier is not eligeble for quotient processing\n",
					$argument_hash->{'event_measuringpoint_user_id'});
			$result{'quotient_decition'} = "no";
		}

		return \%result;
	}
	elsif ($method eq "lbs/get-quotient-counter") {
		send_incrementer_quotient_counter_message($message, $argument_hash);
		# This function returns nothing immediately
	}
	elsif ($method eq "lbs/get-quotient-decition") {
		if ($argument_hash->{'quotient_params_interval'} > 0 && $argument_hash->{'quotient_counter'} % $argument_hash->{'quotient_params_interval'} == 0) {
			return { "quotient_decition" => "yes" };
		}
		return { "quotient_decition" => "no" };
	}
	elsif ($method eq "lbs/set-quotient-diverter-decition") {
		if (is_yes($argument_hash, 'quotient_decition')) {
		       return { "diverter_decition" => "diverge" };
		}
		elsif (is_no($argument_hash, 'quotient_decition')) {
		       return { "diverter_decition" => "straight" };
		}
		return { "diverter_decition" => "reject" };
	}
	elsif ($method eq "lbs/debug-quotient-count") {
		print_info_ident("Quotient decition for carrier with postcode " . zerofill($argument_hash->{'carrier_measuringpoint_postcode_id'}, 4) . " product parameters $argument_hash->{'product_params'} marking property $argument_hash->{'marking_property_short'} counter is $argument_hash->{'quotient_counter'} interval is $argument_hash->{'quotient_params_interval'}: $argument_hash->{'quotient_decition'}\n",
			$argument_hash->{'event_measuringpoint_user_id'});
	}
	elsif ($method eq "lbs/carrier-quotient-divert-check") {
		push @{$activate_groups_array}, "carrier-quotient-diverter-command";

		my $key = zerotrim($argument_hash->{'carrier_measuringpoint_user_id'}) . ":" . zerotrim($argument_hash->{'serial'});
		if (defined cache_lookup (\%global_carrier_save_cache, $key, "saved")) {
			push @{$activate_groups_array}, "carrier-quotient-divert";
			return { "carrier_quotient_divert_possible" => "yes" };
		}

		print_error_ident("Warning: Carrier $key could not be selected for quotient uptake as it was not recently saved on this host.\n", $argument_hash->{'event_measuringpoint_user_id'});

		return {
			"carrier_quotient_divert_possible" => "no",
			"quotient_decition" => "error"
		};
	}
	elsif ($method eq "lbs/send-diverter-command") {
		if ($argument_hash->{'diverter_decition'} eq "reject") {
			print_error_ident("Warning: Not sending any command to diverter $argument_hash->{'diverter_ip'}:$argument_hash->{'diverter_port'}, the product will be rejected.\n",
				$argument_hash->{'event_measuringpoint_user_id'});
			return { "diverter_command_sent" => "no" };
		}

		if (!is_nonempty($argument_hash, 'diverter_ip') or !is_nonzero($argument_hash, 'diverter_port')) {
			print_error_ident("Warning: Missing or invalid address for diverter on this measuringpoint\n", $argument_hash->{'event_measuringpoint_user_id'});
			return { "diverter_command_sent" => "no" };
		}

		my $command = $argument_hash->{'diverter_decition'} eq "diverge" ? $argument_hash->{'diverter_command_diverge'} : $argument_hash->{'diverter_command_straight'};

		print_info_ident("Divert decition is '$argument_hash->{'diverter_decition'}', sending command '$command' to diverter $argument_hash->{'diverter_ip'}:$argument_hash->{'diverter_port'}\n",
			$argument_hash->{'event_measuringpoint_user_id'});

		set_ip($message, $argument_hash->{'diverter_ip'}, $argument_hash->{'diverter_port'}, "udp");
		send_message_ip($message, $command);

		return { "diverter_command_sent" => "yes" };
	}
	elsif ($method eq "lbs/set-weightless-command") {
		return { "weightless_command" => ($argument_hash->{'carrier_twostep_command'} eq "" or $argument_hash->{'carrier_twostep_command'} eq "none")
			? "no"
			: "yes"
		};
	}
	elsif ($method eq "lbs/lookup-stable-weight") {
		unless (is_nonempty($argument_hash, 'scale_ip') and
		        is_nonempty($argument_hash, 'scale_port')
	    	) {
			return { "weight_stable" => "0" };
		}

		my $key = "$argument_hash->{'scale_ip'}:$argument_hash->{'scale_port'}";
		my $weight = cache_lookup_and_clear (\%global_weight_stable_cache, $key, "weight_stable");
		if (defined($weight) and $weight > 0) {
			return {
				"weight_stable" => $weight,
				"weight_stable_is_from_scale" => "yes"
			};
		}

		if ($argument_hash->{'event_measuringpoint_type_name'} ne "KBA_CREATE_CARRIER") {
			return { "weight_stable" => "0" };
		}

		if (tv_interval($argument_hash->{'gettimeofday_process'}) > $STABLE_WEIGHT_CHECK_PERIOD) {
			print_error_ident("No stable weight reading received within $STABLE_WEIGHT_CHECK_PERIOD seconds from automatic scale $key.\n",
				$argument_hash->{'event_measuringpoint_user_id'});
			return { "weight_stable" => "0" };
		}

		return undef;
	}
	elsif ($method eq "lbs/clear-stable-weight") {
		unless (is_nonempty($argument_hash, 'scale_ip') and
		        is_nonempty($argument_hash, 'scale_port') and
		        $argument_hash->{'event_measuringpoint_type_name'} eq "KBA_CREATE_CARRIER"
	    	) {
			return { "weight_stable_cleared" => "no" };
		}

		my $key = "$argument_hash->{'scale_ip'}:$argument_hash->{'scale_port'}";
		if (defined cache_lookup_and_clear (\%global_weight_stable_cache, $key, "weight_stable")) {
			print_info_ident("Unused stable weight reading from scale $key cleared.\n",
				$argument_hash->{'event_measuringpoint_user_id'});
		}

		return { "weight_stable_cleared" => "yes" };
	}
	elsif ($method eq "lbs/set-weight") {
		my %result;
		my $key = $argument_hash->{'scale_ip'} . ":" .  $argument_hash->{'scale_port'};

		if (!is_numeric($argument_hash, 'tare_weight')) {
			return { "weight_check_complete" => "no" };
		}

		$result{'weight_is_stable'} = "no";

		if (is_nonempty ($argument_hash, 'weight')) {
			# Weight from argument, no stable check
			$result{'weight'} = ceil($argument_hash->{'weight'} * 10);
			$result{'weight_is_stable'} = "yes";
		}
		elsif (is_nonzero ($argument_hash, 'weight_stable')) {
			# Weight from manual or confirmed stable input, no stable check
			$result{'weight'} = ceil($argument_hash->{'weight_stable'} * 10);
			if (!is_yes($argument_hash, 'weight_stable_is_from_scale')) {
				$result{'weight_is_stable'} = "yes";
			}
		}
		elsif (!is_yes($argument_hash, 'weightless_command')) {
			# No weight is required for twostep commands

			# Find a weight from weight cache
			my $weight_tmp = cache_lookup (\%global_weight_cache, $key, "weight");
			if (defined ($weight_tmp)) {
				my $weights_history = cache_lookup (\%global_weight_history_cache, $key, "readings");

				if (@{$weights_history} < 2) {
					return undef;
				}

				my $all = "";
				my $test_first = @{$weights_history}[0]->{'weight'};
				foreach my $reading (@{$weights_history}) {
					my $test = $reading->{'weight'};
					if (abs($test_first - $test) > 0.1) {
						my $timeout_s = $global_settings->{'lbs_enrichment_timeout'} * 0.75;
						if (tv_interval($argument_hash->{'gettimeofday_process'}) > $timeout_s * 0.75) {
							print_error_ident("Weight is unstable $test<>$test_first\n", $argument_hash->{'event_measuringpoint_user_id'});
							return { "weight_check_complete" => "no" };
						}
						return undef;
					}
					$all .= ",$test";
				}

				$result{'weight'} = ceil($weight_tmp * 10);
			}

			# Enforce that weight is set when meausuringpoint has a scale
			if ($argument_hash->{'scale_ip'} ne "" and $argument_hash->{'scale_ip'} ne "0") {
				if (!is_nonempty (\%result ,'weight')) {
					print_error_ident("Weight reading from scale $key missing, check connections\n", $argument_hash->{'event_measuringpoint_user_id'});
					return { "weight_check_complete" => "no" };
				}
				elsif ($result{'weight'} <= 1) {
					print_error_ident("Weight reading from scale was not above 0.1 kg, aborting\n", $argument_hash->{'event_measuringpoint_user_id'});
					return { "weight_check_complete" => "no" };
				}
			}
		}

		# If a weight was set, perform tare weight control
		if (is_nonempty (\%result, "weight")) {
			unless ($result{'weight_is_stable'} eq "yes" and $result{'weight'} == 0) {
				if ($result{'weight'} > 9999) {
					print_error_ident("Weight exceeds maximum value ($result{'weight'}>9999)\n", $argument_hash->{'event_measuringpoint_user_id'});
					return { "weight_check_complete" => "no" };
				}

				if ($argument_hash->{'tare_weight'} > $result{'weight'}) {
					print_error_ident("Tare weight exceeds weight from scale ($argument_hash->{'tare_weight'}>$result{'weight'})\n", $argument_hash->{'event_measuringpoint_user_id'});
					return { "weight_check_complete" => "no" };
				}
			}
		}
		else {
			$result{'weight'} = 0;
		}

		if (is_nonzero (\%result, "weight") and is_nonzero($argument_hash, "sequence")) {
			print_error_ident("Sequence transactions are not allowed with positive weights\n", $argument_hash->{'event_measuringpoint_user_id'});
			return { "weight_check_complete" => "no" };
		}

		$result{'weight_check_complete'} = "yes";

		return \%result;
	}
	elsif ($method eq "lbs/set-weight-grams") {
		if (!is_yes($argument_hash, "weight_check_complete")) {
			return undef;
		}

		my $key = $argument_hash->{'scale_ip'} . ":" .  $argument_hash->{'scale_port'};
		my $weight = cache_lookup (\%global_weight_cache, $key, "weight");

		my %result;

		if (is_nonzero($argument_hash, "weight_stable")) {
			$result{"weight_grams"} = ceil($argument_hash->{"weight_stable"} * 1000);
		}
		elsif (defined($weight)) {
			$result{"weight_grams"} = ceil($weight * 1000);
		}
		else {
			$result{"weight_grams"} = $argument_hash->{"weight"} * 100;
		}

		return \%result;
	}
	elsif ($method eq "lbs/group-carrier-save-check") {
		my %result = ( "group_carrier_save_checked" => "yes" );

		if (is_no($argument_hash, 'quotient_decition')) {
			$result{"saved"} = "yes";
		}
		elsif ($argument_hash->{'quotient_decition'} eq "error") {
			$result{"saved"} = "error";
		}
		elsif (is_yes($argument_hash, 'weight_check_complete')) {
			push @{$activate_groups_array}, "carrier-save";
		}
		else {
			$result{"saved"} = "error";
		}

		return \%result;
	}
	elsif ($method eq "lbs/expand-event") {
		if ($argument_hash->{'carrier_twostep_command'} ne "SLETT" and $argument_hash->{'carrier_twostep_command'} ne "none" and $argument_hash->{'carrier_twostep_command'} ne "KVOT") {
			print_error("Invalid value '$argument_hash->{'carrier_twostep_command'}' for carrier_twostep_command\n");
			return { "expand_event_complete" => "no" };
		}

		if ($argument_hash->{'source_meetingpoint_user_id'} == 20999) {
			print_info_ident("Not saving anything for carrier $argument_hash->{'print_barcode'} as meetingpoint " . $argument_hash->{'source_meetingpoint_user_id'} . " is set to be ignored\n",
				$argument_hash->{'event_measuringpoint_user_id'});
			push @{$activate_groups_array}, "carrier-save-ignore";
			return { "expand_event_complete" => "yes" };
		}

		if ($argument_hash->{'marking_property_long'} == 42) {
			print_info_ident("Not saving anything for carrier $argument_hash->{'print_barcode'} as markings with property " . $argument_hash->{'marking_property_long'} . " are set to be ignored\n",
				$argument_hash->{'event_measuringpoint_user_id'});
			push @{$activate_groups_array}, "carrier-save-ignore";
			return { "expand_event_complete" => "yes" };
		}

		my %result = (
			"event_code_primary" => "0",
			"event_code_secondary" => "0",
			"event_migration" => "0",
			"expand_event_complete" => "yes"
		);

		my %activate_groups;

		if ($argument_hash->{'code_prefix'} eq "TK" or $argument_hash->{'code_prefix'} eq "5Y") {
			$activate_groups{'ignore'} = 1;
		}
		elsif ($argument_hash->{'carrier_twostep_command'} eq "KVOT") {
			push @{$activate_groups_array}, "carrier-save-quotient-uptake";
			$result{"event_code_primary"} = "400";
		}
		elsif (is_yes($argument_hash, 'quotient_decition')) {
			$result{"event_code_primary"} = "402";
		}
		elsif ($argument_hash->{'carrier_twostep_command'} eq "SLETT") {
			$result{"event_code_primary"} = "700";
		}
		elsif ($argument_hash->{'carrier_twostep_command'} eq "none") {
			if ($argument_hash->{'code_prefix'} eq "1Y") {
				if ($argument_hash->{'event_measuringpoint_type_name'} eq "SORTING_POINT") {
					$result{'event_code_primary'} = "500";

					$activate_groups{'primary'} = 1;
				}
				elsif ($argument_hash->{'event_measuringpoint_type_name'} eq "TERMINATION_POINT") {
					$result{'event_code_primary'} = "501";

					$activate_groups{'primary'} = 1;
				}
				elsif ($argument_hash->{'weight'} > 0) {
					$result{'event_code_primary'} = "350";
					$result{'event_code_secondary'} = "300";
					$result{'event_migration'} = $argument_hash->{'weight'};

					$activate_groups{'primary'} = 1;
					$activate_groups{'secondary'} = 1;
				}
				else {
					$result{'event_code_primary'} = "300";
	
					$activate_groups{'primary'} = 1;
				}
			}
			else {
				$result{'event_code_primary'} = "300";
				$result{'event_code_secondary'} = "100";

				$activate_groups{'primary'} = 1;
				$activate_groups{'secondary'} = 1;
				$activate_groups{'save'} = 1;

				print_info_ident("Save new carrier $argument_hash->{'print_barcode'}" .
					" seq $argument_hash->{'sequence'}" .
					" type $argument_hash->{'carrier_type'}" .
					" weight $argument_hash->{'weight'}" .
					" tare weight $argument_hash->{'tare_weight'}" .
					" tray count $argument_hash->{'tray_count'}" .
					"\n",
					$argument_hash->{'event_measuringpoint_user_id'});
			}
		}

		if (defined $activate_groups{'ignore'}) {
			push @{$activate_groups_array}, "carrier-save-ignore";
		}
		elsif (defined $activate_groups{'primary'} and defined $activate_groups{'secondary'} and defined $activate_groups{'save'}) {
			push @{$activate_groups_array}, "carrier-save-event-primary";
			push @{$activate_groups_array}, "carrier-save-event-secondary";
			push @{$activate_groups_array}, "carrier-save-carrier";
			push @{$activate_groups_array}, "carrier-save-confirm-all";
		}
		elsif (defined $activate_groups{'primary'} and defined $activate_groups{'secondary'}) {
			push @{$activate_groups_array}, "carrier-save-event-primary";
			push @{$activate_groups_array}, "carrier-save-event-secondary";
			push @{$activate_groups_array}, "carrier-save-confirm-primary-secondary";
		}
		else {
			push @{$activate_groups_array}, "carrier-save-event-primary";
			push @{$activate_groups_array}, "carrier-save-confirm-primary";
		}

		if ($result{'event_code_primary'} ne "0") {
			print_info_ident("Save event $result{'event_code_primary'} for carrier $argument_hash->{'print_barcode'} migration $result{'event_migration'}\n",
					$argument_hash->{'event_measuringpoint_user_id'});
		}

		if ($result{'event_code_secondary'} ne "0") {
			print_info_ident("Save event $result{'event_code_secondary'} for carrier $argument_hash->{'print_barcode'}\n",
					$argument_hash->{'event_measuringpoint_user_id'});
		}

		return \%result;
	}
	elsif ($method eq "lbs/carrier-save-carrier-cache") {
		my $key = zerotrim($argument_hash->{'carrier_measuringpoint_user_id'}) . ":" . zerotrim($argument_hash->{'serial'});
		cache_push (\%global_carrier_save_cache, $key, "saved", "yes");
		return { "carrier_cache_saved" => "yes" };
	}
	elsif ($method eq "lbs/carrier-save-confirm-primary") {
		return { "saved" => $argument_hash->{"event_primary_saved"} };
	}
	elsif ($method eq "lbs/carrier-save-confirm-all") {
		return { "saved" => ( is_yes($argument_hash, "event_primary_saved") and
		                      is_yes($argument_hash, "event_secondary_saved") and
		                      is_yes($argument_hash, "carrier_saved")
		                    )
		                    ? "yes"
		                    : "no"
		};
	}
	elsif ($method eq "lbs/carrier-save-confirm-primary-secondary") {
		return { "saved" => ( is_yes($argument_hash, "event_primary_saved") and
		                      is_yes($argument_hash, "event_secondary_saved")
		                    )
		                    ? "yes"
		                    : "no"
		};
	}
	elsif ($method eq "lbs/carrier-save-ignore") {
		return { "saved" => "yes" };
	}
	elsif ($method eq "lbs/sort-printers") {
		my @printer_keys = qw/ip port template chute_max chute_min/;

		my $avkast = $argument_hash->{'chute_name'};
		$avkast =~ s/\D//g;
		$avkast =~ s/^0+//;

		if ($avkast eq "") {
			$avkast = "0";
		}

		my @distance_list;
		my @printer_list;
		for (my $i = 0; $i < $argument_hash->{'printer_count'}; $i++) {
			my $distance = 999999;
			
			my %printer;
			foreach my $key (@printer_keys) {
				$printer{$key} = $argument_hash->{"printer_" . $i . "_$key"};
			}

			if ( is_nonempty (\%printer, 'chute_min') &&
			     is_nonempty (\%printer, 'chute_max')
			) {
				if ($avkast >= $printer{'chute_min'} && $avkast <= $printer{'chute_max'}) {
					$distance = 0;
				}
				else {
					my $distance_a = abs($avkast - $printer{'chute_min'});
					my $distance_b = abs($avkast - $printer{'chute_max'});
					
					$distance = $distance_a < $distance_b ? $distance_a : $distance_b;
				}
			}

			$distance = zerofill($distance, 4);

			push(@distance_list, "$distance-$i");
			push(@printer_list, \%printer);

			#print_debug("Printer $printer{'ip'}: min: $printer{'chute_min'}, max: $printer{'chute_max'}, distance to avkast $avkast is $distance\n");
		}

		my %result;
		my $final_i = 0;
		foreach my $pair (sort @distance_list) {
			$pair =~ /^(.+)-(.+)$/;
			my $distance = $1;
			my $i = $2; 

			foreach my $key (@printer_keys) {
				$result{"printer_sorted_" . $final_i . "_$key"} = $printer_list[$i]->{$key}
			}

			#print_debug("Printer $final_i: $printer_list[$i]->{'ip'}\n");

			$final_i++;
		}

		$result{'printer_sorted_count'} = $argument_hash->{'printer_count'};

		return \%result;
	}
	elsif ($method eq "lbs/print-wait") {
		# If there are still older messages in the queue from the same source, wait
		foreach my $id (keys(%global_enrichment_cache)) {
			if ($id < $argument_hash->{'message_id'}) {
				my $test_msg = $global_enrichment_cache{$id};
				if (is_yes ($test_msg, 'print_wait_ignore')) {
					next;
				}
				if (is_nonzero ($argument_hash, 'machine')) {
					if ( is_nonzero ($test_msg, 'machine') and
					     $test_msg->{'machine'} eq $argument_hash->{'machine'}
					) {
						return undef;
					}
				}
				if ( is_nonempty ($argument_hash, 'scanner_ip') and
				     is_nonempty ($argument_hash, 'scanner_port')
				) {
					if ( is_nonempty ($test_msg, 'scanner_ip') and
					     is_nonempty ($test_msg, 'scanner_port') and
					     $test_msg->{'scanner_ip'} eq $argument_hash->{'scanner_ip'} and
					     $test_msg->{'scanner_port'} eq $argument_hash->{'scanner_port'}
					) {
						return undef;
					}
				}
			}
		}
		return {
			'print_wait_complete' => 'yes'
		};
	}
	elsif ($method eq "lbs/group-carrier-print-check") {
		my %result = ( "group_carrier_print_checked" => "yes" );
		if ($argument_hash->{'weight_check_complete'} eq "yes") {
			push @{$activate_groups_array}, "carrier-print";
		}
		else {
			$result{"printed"} = "no";
		}
		return \%result;
	}
	elsif ($method eq "lbs/print-copies-ensure") {
		return { "print_copies" => $global_settings->{'lbs_print_copies'}};
	}
	elsif ($method eq "lbs/debug-print") {
		my @keys = qw/command_source chute_name marking_postcode_id marking_text marking_text_extra print_barcode print_copies event_measuringpoint_user_id print_decition weight tare_weight sequence/;
		my %values;

		foreach my $key (@keys) {
			$values{$key} = exists $argument_hash->{$key} ? $argument_hash->{$key} : "";
		}

		my $label_text = zerofill($values{'marking_postcode_id'}, 4) .
			" $values{'marking_text'}" .
			" - $values{'marking_text_extra'}";

		if (is_yes(\%values, 'print_decition')) {
			print_info_ident("Printing label '$values{'print_barcode'}' seq '$values{'sequence'}' command source '$values{'command_source'}' chute '$values{'chute_name'}' weight '$values{'weight'}' tare weight '$values{'tare_weight'}' - $values{'print_copies'} " . ($values{'print_copies'} == 1 ? "copy" : "copies") . " - $label_text\n", $values{'event_measuringpoint_user_id'});
		}
		else {
			print_info_ident("Processing complete for '$values{'print_barcode'}' command source '$values{'command_source'}' - $label_text\n", $values{'event_measuringpoint_user_id'});
		}

		return { "debug_print_done" => "yes" };
	}
	elsif ($method eq "lbs/printer-ip-force-ensure") {
		return { "printer_ip_force" => $global_settings->{'lbs_printer_ip_force'} };
	}
	elsif ($method eq "lbs/print-disable-ensure") {
		return { "print_disable" => $global_settings->{'lbs_print_disable'} };
	}
	elsif ($method eq "lbs/print-failover-ensure") {
		return { "print_failover" => $global_settings->{'lbs_print_failover'} };
	}
	elsif ($method eq "lbs/print") {
		if (is_yes($argument_hash, 'print_decition')) {
			$message->clear_array();
			$message->ip_clear();

			$argument_hash->{'weight'} /= 10;

			foreach my $key (sort(keys(%{$argument_hash}))) {
				if (!is_set ($argument_hash, $key)) {
					print_error("Warning: Value $key to lbs/print was not set\n");
				}
				set_tag_str($message, $key, defined $argument_hash->{$key} ? $argument_hash->{$key} : "");
			}

			if (!is_nonzero ($argument_hash, 'printer_sorted_count')) {
				print_error_ident("No printers found for carrier type " . $argument_hash->{'carrier_type'} .
				                  " label group " . $argument_hash->{'label_group_id'}, $argument_hash->{'event_measuringpoint_user_id'});
			}
			else {
				$message->{'topic'} = $global_settings->{'lbs_topic_print'};

				for (my $i = 0; $i < $argument_hash->{'print_copies'}; $i++) {
					$message->send();
				}

				return {
					'printed' => 'yes',
					'print_wait_ignore' => 'yes'
				};
			}
		}
		return {
			'printed' => 'no',
			'print_wait_ignore' => 'yes'
		};
	}
	elsif ($method eq "lbs/send-push-notification") {
		# Only send for HTTP clients
		if (	is_zero ($argument_hash, 'scanner_port') and
			is_nonempty ($argument_hash, 'scanner_ip') and
			!is_no ($argument_hash, 'saved') and 
			!is_yes ($argument_hash, 'no_push_notification')
		) {
			set_ip($message, $argument_hash->{'scanner_ip'}, $argument_hash->{'scanner_port'}, "tcp");
			if ($argument_hash->{'saved'} eq "error") {
				send_log_message_push($message, "err", "Error - Check logs");
				send_log_message_beep($message, "error");
			}
			else {
				send_log_message_push($message, "info", "OK");
				send_log_message_beep($message, "ok");
			}
			return { 'push_notification_sent' => 'yes' };
		}
		return { 'push_notification_sent' => 'no' };
	}
	elsif ($method eq "lbs/send-scanner-ack") {
		# Only send for UDP scanners
		if (	is_nonzero($argument_hash, 'scanner_port') and
			is_yes($argument_hash, 'saved')
		) {
			set_ip($message, $argument_hash->{'scanner_ip'}, $argument_hash->{'scanner_port'}, "udp");
			send_message_ip($message, "\x02A\x03");
			return { 'scanner_ack_sent' => 'yes' };
		}
		return { 'scanner_ack_sent' => 'no' };
	}
	elsif ($method eq "lbs/carrier-twostep-reprocess") {
		my %result = ( "carrier_twostep_reprocess_complete" => "yes" );

		if (!is_yes($argument_hash, "saved") or $argument_hash->{'carrier_twostep_command_reprocess'} eq "none") {
			return \%result;
		}

		my %new_message = (
			"carrier_twostep_command_reprocess" => $argument_hash->{'carrier_twostep_command_reprocess'},
			"barcode" => $argument_hash->{'print_barcode'},
			"scanner_ip" => $argument_hash->{'scanner_ip'},
			"scanner_port" => $argument_hash->{'scanner_port'},
			"weight_grams" => $argument_hash->{'weight_grams'},
			"weight" => $argument_hash->{'weight'} / 10.0,
			"tare_weight" => $argument_hash->{'tare_weight'} / 10.0,
			"tray_count" => $argument_hash->{'tray_count'}
		);

		enrichment_cache_queue(\%new_message);

		return \%result;

	}
	elsif ($method eq "lbs/group-aths-check") {
		if ($argument_hash->{'code_prefix'} eq "LB") {
			push @{$activate_groups_array}, "lb_lookup";
		}
		return { 'group_aths_checked' => "yes" };
	}
	elsif ($method eq "aths/lb-lookup") {
		print_info_ident("Sending ATHS LB Lookup request for barcode $argument_hash->{'lb_lookup_barcode'}\n", $argument_hash->{'event_measuringpoint_user_id'});

		set_tag_blob($message, "lbcode", $argument_hash->{'lb_lookup_barcode'});
		set_tag_blob($message, "responsetopic", $argument_hash->{'lb_lookup_barcode'}); # Will be postfixed to the response topic prefix
		set_tag_blob($message, "responseparameter", 'print_barcode');

		$message->{'topic'} = $global_settings->{'lbs_topic_aths_lb_lookup_request'};
		$message->send();
	}
	elsif ($method eq "lbs/timereg-twostep-lookup") {
		my $cache_msg = cache_lookup_hashref(\%global_twostep_cache, "$argument_hash->{'scanner_ip'}:$argument_hash->{'scanner_port'}");
		if (defined $cache_msg && is_nonzero($cache_msg, 'timereg_meetingpoint_user_id')) {
			return {
				'timereg_prefix' => $cache_msg->{'timereg_prefix'},
				'timereg_meetingpoint_user_id' => $cache_msg->{'timereg_meetingpoint_user_id'},
				'timereg_suffix' => $cache_msg->{'timereg_suffix'}
			};
		}
		else {
			if (is_nonzero($argument_hash, 'timereg_meetingpoint_user_id_default')) {
				return {
					'timereg_prefix' => "TA",
					'timereg_meetingpoint_user_id' => $argument_hash->{'timereg_meetingpoint_user_id_default'},
					'timereg_suffix' => "1000"
				};
			}
			else {
				print_error("Missing two-step command for time registration subject '$argument_hash->{'timereg_subject'}'");
				return { 'saved' => "error" };
			}
		}
	}
	elsif ($method eq "lbs/debug-timereg") {
		if (is_yes($argument_hash, 'timereg_expired')) {
			print_error_ident("Time registration failed for meetingpoint $argument_hash->{'timereg_meetingpoint_user_id'} subject $argument_hash->{'timereg_subject_prefix'}$argument_hash->{'timereg_subject'}, the temporary code has expired or is not yet active.\n", $argument_hash->{'event_measuringpoint_user_id'});
		}
		else {
			print_info_ident("Save time registration meetingpoint $argument_hash->{'timereg_meetingpoint_user_id'} subject $argument_hash->{'timereg_subject_prefix'}$argument_hash->{'timereg_subject'} serial $argument_hash->{'serial'}\n", $argument_hash->{'event_measuringpoint_user_id'});
		}

		return { 'debug_timereg_done' => "yes" }
	}
	elsif ($method =~ /^(lbs\/api\/.+)$/) {
		my $endpoint = $1;

		my %result;

		if (defined $endpoint_override) {
			$endpoint = $endpoint_override;
			$message->{'topic'} = $endpoint_override;

			foreach my $key (keys(%{$argument_hash})) {
				$message->push_tag_str($key, $argument_hash->{$key});
			}

			if ($API_DEBUG_ASYNC) {
				print_info("API request topic (overridden) $endpoint_override\n");
			}
		}
		else {
			if (defined $argument) {
				$endpoint .= "/$argument";
			}

			$message->{'topic'} = $endpoint;

			if ($API_DEBUG_ASYNC) {
				print_info("API request topic $endpoint\n");
			}
		}

		if ($method =~ /carrier-save-event-(primary|secondary)/) {
			$message->push_tag_str("http_method", "PUT");
			$result{"event_" . $1 . "_saved"} = "yes";
		}
		elsif ($endpoint =~ /\/carrier\//) {
			$message->push_tag_str("http_method", "PUT");
			$result{"carrier_saved"} = "yes";
		}
		elsif ($endpoint =~ /\/quotient\//) {
			$message->push_tag_str("http_method", "PUT");
			$result{"quotient_uptake_saved"} = "yes";
		}
		elsif ($endpoint =~ /\/timereg\//) {
			$message->push_tag_str("http_method", "PUT");
			$result{"saved"} = "yes";
		}
		else {
			$message->push_tag_str("http_method", "GET");
		}

		if (!defined $api_call_hashref_queue->{$endpoint}) {
			$api_call_hashref_queue->{$endpoint} = 1;
			$message->send();
		}

		if (keys(%result) > 0) {
			return \%result;
		}
	}
	else {
		print_error("Unknown method '$method' to process_api_request()\n");
	}

	return undef;
}

sub enrichment_cache_add {
	my $hashref = shift;
	$hashref->{'gettimeofday_process'} = [gettimeofday];
	$hashref->{'gettimeofday_something_happened'} = [gettimeofday];
	$hashref->{'gettimeofday_grace'} = [gettimeofday];
	cache_push_hashref(\%global_enrichment_cache, $hashref->{'message_id'}, $hashref);
}

sub enrichment_cache_queue {
	my $hashref = shift;

	$hashref->{'gettimeofday_queue'} = [gettimeofday];
	$hashref->{'message_id'} = $global_enrichment_serial++;

	# Always add cancel commands directly to queue
	if (is_yes ($hashref, "cancel")) {
		enrichment_cache_add($hashref);
	}
	else {
		push @global_enrichment_input_queue, $hashref;
	}
}

sub enrichment_cache_enrich {
	my $response = shift;

	foreach my $msg_key (keys(%global_enrichment_cache)) {
		my $msg = $global_enrichment_cache{$msg_key};

		foreach my $match_rule_key (keys(%global_api_matrix)) {
			my $match_rule = $global_api_matrix{$match_rule_key};

			my $match_keys = $match_rule->{'response_matches'};
			my $output_keys = $match_rule->{'outputs'};
			my $output_prefixes = $match_rule->{'output_prefixes'};

			if ($API_DEBUG_RESPONSE) {
				print_info ("Check return rule $match_rule_key\n");
			}

			my $did_match = 1;

			if (@{$match_keys} == 0) {
				if ($API_DEBUG_RESPONSE) {
					print_info ("- Mismatch, no response keys set\n");
				}
				$did_match = 0;
			}

			if (!$did_match) {
				next;
			}

			foreach my $match_key (@{$match_keys}) {
				# Empty values are not valid for response matching
				if (is_nonempty ($response, $match_key)) {
					if (    exists $msg->{$match_key} &&
					        $msg->{$match_key} eq $response->{$match_key}
					) {
						# OK, string match
					}
					elsif ( exists $msg->{$match_key} &&
					        $msg->{$match_key} =~ /^\d+$/ &&
						$response->{$match_key} =~ /^\d+$/ &&
						$msg->{$match_key} == $response->{$match_key}
					) {
						# OK, numeric match
					}
					else {
						if ($API_DEBUG_RESPONSE) {
							print_info ("- Mismatch, response key $match_key not matching '" .
								(defined $msg->{$match_key} ? $msg->{$match_key} : "") .
								"'<>'$response->{$match_key}'\n"
							);
						}
						$did_match = 0;
					}
				}
				else {
					if ($API_DEBUG_RESPONSE) {
						print_info ("- Mismatch, response key $match_key missing or empty\n");
					}
					$did_match = 0;
				}
			}

			if (!$did_match) {
				next;
			}

			foreach my $output_key (@{$output_keys}) {
				# Empty output values allowed
				if (!is_set ($response, $output_key)) {
					if ($API_DEBUG_RESPONSE) {
						print_info ("- Mismatch, output key $output_key missing\n");
					}
					$did_match = 0;
				}
			}

			if (!$did_match) {
				next;
			}

			if ($API_DEBUG || $API_DEBUG_RESPONSE) {
				print_info ("Return check match for $match_rule_key, method is " . (exists $msg->{'applied_methods'}->{$match_rule_key} ? "" : "not ") . "applied\n");
			}

			foreach my $output_key (@{$output_keys}) {
				my $value = is_nonempty($response, $output_key) ? $response->{$output_key} : "";
				if ($API_DEBUG) {
					if (is_set ($msg, $output_key)) {
						print_info("-- Replacing old value of $output_key=$msg->{$output_key} with $value} in message\n");
					}
					else {
						print_info("-- Adding value $output_key=$value to message\n");
					}
				}
				$msg->{$output_key} = $value;
			}

			foreach my $prefix (@{$output_prefixes}) {
				foreach my $response_key (keys(%{$response})) {
					if ($response_key =~ /^\Q$prefix\E/) {
						$msg->{$response_key} = $response->{$response_key};
					}
				}
			}

			$msg->{'gettimeofday_something_happened'} = [gettimeofday];
			$msg->{'gettimeofday_grace'} = [gettimeofday];
		}
	}
}

sub try_process_api_response {
	my $message = shift;

	if ($message->{'topic'} =~ /^\Q$global_settings->{'lbs_topic_incrementer_id_prefix'}\E\/.*\/(\d+)$/) {
		$message->push_tag_str("serial", $1);
	}
	elsif ($message->{'topic'} =~ /^\Q$global_settings->{'lbs_topic_incrementer_quotient_counter_prefix'}\E\/.*\/(\d+)$/) {
		$message->push_tag_str("quotient_counter", $1);
	}
	elsif ($message->{'topic'} !~ /^\/?lbs\/api\/?/) {
		return 0;
	}

	foreach my $prefix (@API_RESPONSE_TOPICS_IGNORE) {
		if ($message->{'topic'} =~ /^\Q$prefix\E/) {
			if ($API_DEBUG_RESPONSE) {
				print_info ("API RESPONSE $message->{'topic'} (ignored)\n");
			}
			return 1;
		}
	}

	if ($API_DEBUG_RESPONSE) {
		print_info ("API RESPONSE $message->{'topic'}\n");
	}

	my %response;
	foreach my $tag ($message->get_tag_names()) {
		$response{$tag} = get_from_tag_first($message, $tag);
		if ($API_DEBUG_RESPONSE) {
			# Value might be undefined
			my $value = is_nonempty(\%response, $tag) ? $response{$tag} : "";
			print_info ("- $tag => $value\n");
		}
	}

	enrichment_cache_enrich(\%response);

	return 1;
}

sub process {
	my $message = shift;

	if (try_process_api_response($message)) {
		# OK, message was an API response
	}
	elsif ($message->{'topic'} =~ /^\Q$global_settings->{'lbs_topic_aths_lb_lookup_response'}\E/) {
		my %response;

		if ($message->{'topic'} =~ /(LB\d+NO)/) {
			$response{'lb_lookup_barcode'} = $1;
			$response{'print_barcode'} = get_from_tag_first($message, "print_barcode");
			$response{'saved'} = "yes";

			enrichment_cache_enrich(\%response);
		}
		else {
			print_error ("Invalid topic $message->{'topic'} in LB lookup response, original barcode LBxxxxNO not found\n");
		}
	}
	elsif ($message->{'topic'} =~ /^httpserver\/.+/ && defined get_from_tag_first($message, "check")) {
		# OK, some other service checks if httpserver is running
	}
	else {
		my $hostname = lc hostname;
		if ($global_settings->{'lbs_fake_hostname'} ne "") {
			$hostname = $global_settings->{"lbs_fake_hostname"};
		}
		$hostname = lc $hostname;

		my ($ip, $port) = get_ip_and_port($message);

		my $ip_override = get_from_tag_first($message, "ip");
		if (defined $ip_override) {
			$ip = $ip_override;
		}

		my $port_override = get_from_tag_first($message, "port");
		if (defined $port_override) {
			$port = $port_override;
		}

		my $machine = get_from_tag_first($message, "machine");

		if (!defined $port) {
			$port = 0;
		}

		if (defined $ip or defined $machine) {
			my %cache_message;
		       
			if (defined $ip) {
				$cache_message{'scanner_ip'} = $ip;
				$cache_message{'scanner_port'} = $port;
			}
			if (defined $machine) {
				$cache_message{'machine'} = $machine;
			}


			# my @tags = qw/push_service weight unladenweight barcode reading marking_id tableau_id tidreg_mpid
			# stacker namesortplan transportmethod processdegree velocity label/;
			my @tags = $message->get_tag_names();
			foreach my $tag (@tags) {
				my $value = get_from_tag_first($message, $tag);
				if (defined $value) {
					$cache_message{$tag} = $value;
				}
			}

			enrichment_cache_queue(\%cache_message);
		}
	}

	return 1;
}

sub process_endpoint_replacements {
	my $msg = shift;
	my $endpoint = shift;

	my @keys;

	my $endpoint_tmp = $endpoint;
	while ($endpoint_tmp =~ s/\{([^\{\}]+)\}//) {
		push @keys, $1;
	}

	foreach my $key (@keys) {
		if (is_nonempty ($msg, $key)) {
			$endpoint =~ s/\{\Q$key\E\}/$msg->{$key}/;
		}
		else {
			print_error("Warning: Key $key defined in E: in a rule did not exist in the message\n");
		}
	}

	return $endpoint;
}

sub enrichment_rule_check_need_execute {
	my $cache_message = shift;
	my $rule = shift;
	my $no_async_allowed = shift;

	if (	defined $cache_message->{'applied_methods'}->{$rule->{'name'}} or
		!defined $cache_message->{'active_methods'}->{$rule->{'name'}}
	) {
		return 0;
	}

	if (@{$rule->{'response_matches'}} > 0 and $no_async_allowed) {
		return 0;
	}

	my $do_execute_rule = 0;
	foreach my $required_field (@{$rule->{'outputs'}}) {
		if (!is_set($cache_message, $required_field)) {
			#print_info("Rule $method output $required_field missing\n");
			$do_execute_rule = 1;
			last;
		}
	}
	return $do_execute_rule;
}

# This function is called multiple timed for every message, rules may be applied in any resolvable order
sub enrichment_cache_message_check_and_apply_rules {
	my $rrr_message = shift;
	my $cache_message = shift;
	my $cache_message_id = shift;
	my $api_call_hashref_queue = shift;
	my $no_async_allowed = shift;

	if (tv_interval($cache_message->{'gettimeofday_grace'}) < 0) {
		if ($API_DEBUG || $API_DEBUG_NOT_APPLIED_RULES) {
			#			print_info("Message graced " . tv_interval($cache_message->{'gettimeofday_grace'}) . "\n");
		}
		return;
	}

	# Set undefined values to empty strings
	foreach my $key (keys(%{$cache_message})) {
		if (!defined ($cache_message->{$key})) {
			$cache_message->{$key} = "";
		}
	}

	# Check for new message, initialize structures
	if (!defined($cache_message->{'applied_methods'})) {
		$cache_message->{'active_methods'} = {};
		$cache_message->{'applied_methods'} = {};
		$cache_message->{'applied_methods_history'} = [];

		# Activate all methods which do no have any groups specified
		foreach my $method (keys(%global_api_matrix)) {
			if (keys(%{$global_api_matrix{$method}->{'method_groups'}}) == 0) {
				if ($API_DEBUG || $API_DEBUG_NOT_APPLIED_RULES) {
					print_info("Activate method $method\n");
				}
				$cache_message->{'active_methods'}->{$method} = 1;
			}
		}
	}
	#print_info ("Message applied methods: @{$cache_message->{'applied_methods_history'}}\n");

	#my $time_elapsed_ms_tmp = floor (tv_interval($cache_message->{'gettimeofday'}) * 1000.0);
	#print_info ("Current processing time : $time_elapsed_ms_tmp ms\n");

	if ($API_DEBUG_NOT_APPLIED_RULES or $API_DEBUG) {
		print_info("Checking methods for message\n");
	}

	my $something_happened = 0;
	my $all_rules_applied = 1;
	foreach my $method (keys(%global_api_matrix)) {
		my $rule = $global_api_matrix{$method};

		if (!enrichment_rule_check_need_execute($cache_message, $rule, $no_async_allowed)) {
			#print_info("Rule $method outputs already present\n");
			next;
		}

		$all_rules_applied = 0;

		if ($API_DEBUG_NOT_APPLIED_RULES) {
			print_info("- Method $method not yet applied\n");
		}

		my $all_fields_present = 1;
		my @arguments_tmp;
		my %arguments_tmp_hash;
		foreach my $field (@{$rule->{'inputs'}}) {
			if (!is_set($cache_message, $field)) {
				if ($API_DEBUG_NOT_APPLIED_RULES) {
					print_info("- - Field $field missing\n");
				}
				$all_fields_present = 0;
				last;
			}

			# Don't use empty string in API calls, replace with 0
			my $value = $cache_message->{$field} eq "" ? "0" : $cache_message->{$field};

			push @arguments_tmp, $value;
			$arguments_tmp_hash{$field} = $value;
		}
		if (!$all_fields_present) {
			next;
		}

		if ($API_DEBUG) {
			print_info("Apply API method $method arguments " . join (",", @arguments_tmp) . "\n");
		}


		if ($rule->{'full_message'}) {
			foreach my $field (keys(%{$cache_message})) {
				$arguments_tmp_hash{$field} = $cache_message->{$field};
			}
		}

		my @activate_groups_tmp_array;

		my $result = process_api_request (
			$rrr_message,
			$cache_message,
			$method,
			join ("/", @arguments_tmp),
			\%arguments_tmp_hash,
			\@activate_groups_tmp_array,
			$api_call_hashref_queue,
			defined $rule->{'endpoint'}
				? process_endpoint_replacements($cache_message, $rule->{'endpoint'})
				: undef
		);

		if (defined $result) {
			# Some API requests give immediate result
			foreach my $key (keys(%{$result})) {
				if ($API_DEBUG) {
					print_info("-- Set value $key=$result->{$key}\n");
				}
				$cache_message->{$key} = $result->{$key};
			}

			$something_happened = 1;
		}

		if (!$rule->{'again'} || defined $result) {
			$cache_message->{'applied_methods'}->{$method} = 1;
			push (@{$cache_message->{'applied_methods_history'}}, $method);
		}

		foreach my $group (@activate_groups_tmp_array) {
			if ($API_DEBUG) {
				print_info("Activate group $group\n");
			}
			foreach my $method (keys(%global_api_matrix)) {
				if (defined $global_api_matrix{$method}->{'method_groups'}->{$group}) {
					if ($API_DEBUG) {
						print_info("- Activate method $method\n");
					}
					$cache_message->{'active_methods'}->{$method} = 1;

					$something_happened = 1;
				}
			}
		}
	}

	if ($something_happened) {
		$cache_message->{'gettimeofday_something_happened'} = [gettimeofday];
	}
	else {
		$cache_message->{'gettimeofday_grace'} = get_future_time($ENRICHMENT_NOTHING_HAPPENED_PAUSE_MS * 1000);
	}

	if ($all_rules_applied) {
		if ($API_DEBUG_COMPLETION) {
			print_info("Message complete, applied rule count: " . ($#{$cache_message->{'applied_methods_history'}} + 1). "\n");

			my $time_elapsed_queue_ms = floor (tv_interval($cache_message->{'gettimeofday_queue'}) * 1000.0);
			my $time_elapsed_process_ms = floor (tv_interval($cache_message->{'gettimeofday_process'}) * 1000.0);
			print_info ("Total processing time: $time_elapsed_process_ms ms, total time: $time_elapsed_queue_ms ms\n");
		}

		delete $global_enrichment_cache{$cache_message_id};
	}
}

sub source {
	my $message = shift;

	my %api_call_endpoints_tmp;

	while (@global_enrichment_input_queue > 0 and keys(%global_enrichment_cache) < $ENRICHMENT_CACHE_MAX) {
		my $hashref = shift @global_enrichment_input_queue;
		enrichment_cache_add($hashref);
	}

	if (@global_enrichment_input_queue > 1000) {
		print_error("Warning: " . scalar(@global_enrichment_input_queue) . " messages in enricher input queeue\n");
	}

	cache_housekeep_all();

	# Only send async requests for the first messages in the queue, allowing them
	# to complete first. If we are lucky, the other messages get enriched with
	# the responses as well.
	my $no_async_allowed_limit = $ENRICHMENT_ASYNC_ALLOWED_LIMIT;
	foreach my $msgid (sort { $a <=> $b } keys(%global_enrichment_cache)) {
		my $msg = $global_enrichment_cache{$msgid};

		if (!defined $msg) {
			# Messages may cause other messages to be deleted
			next;
		}

		enrichment_cache_message_check_and_apply_rules(
			$message,
			$msg,
			$msgid,
			\%api_call_endpoints_tmp,
			(--$no_async_allowed_limit <= 0 ? 1 : 0)
		);
	}

	return 1;
}
